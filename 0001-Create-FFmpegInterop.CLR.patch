From 5b3b8ae8fa3b7e21d115c3f5583082829a919600 Mon Sep 17 00:00:00 2001
From: Dave Diffenbaugh <daviddi@microsoft.com>
Date: Thu, 1 Feb 2018 23:32:54 -0800
Subject: [PATCH 1/2] Create FFmpegInterop.CLR

---
 .../CLR/FFmpegInterop.CLR/AssemblyInfo.cpp         |   38 +
 .../CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.cpp    |    6 +
 .../CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.h      |   13 +
 .../FFmpegInterop.CLR/FFmpegInterop.CLR.vcxproj    |  178 +++
 .../FFmpegInterop.CLR.vcxproj.filters              |   65 +
 .../CLR/FFmpegInterop.CLR/FFmpegInteropLogging.cpp |   68 +
 .../CLR/FFmpegInterop.CLR/FFmpegInteropLogging.h   |   37 +
 .../CLR/FFmpegInterop.CLR/FFmpegInteropMSS.cpp     |  936 +++++++++++++
 .../CLR/FFmpegInterop.CLR/FFmpegInteropMSS.h       |  157 +++
 .../CLR/FFmpegInterop.CLR/FFmpegReader.cpp         |   88 ++
 FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegReader.h |   49 +
 .../FFmpegInterop.CLR/H264AVCSampleProvider.cpp    |  169 +++
 .../CLR/FFmpegInterop.CLR/H264AVCSampleProvider.h  |   41 +
 .../CLR/FFmpegInterop.CLR/H264SampleProvider.cpp   |   72 +
 .../CLR/FFmpegInterop.CLR/H264SampleProvider.h     |   40 +
 FFmpegInterop/CLR/FFmpegInterop.CLR/ILogProvider.h |   43 +
 .../CLR/FFmpegInterop.CLR/MediaSampleProvider.cpp  |  217 +++
 .../CLR/FFmpegInterop.CLR/MediaSampleProvider.h    |   84 ++
 .../CLR/FFmpegInterop.CLR/MediaThumbnailData.h     |   58 +
 .../CLR/FFmpegInterop.CLR/MyMediaStreamSample.cpp  |   18 +
 .../CLR/FFmpegInterop.CLR/MyMediaStreamSample.h    |   15 +
 FFmpegInterop/CLR/FFmpegInterop.CLR/ReadMe.txt     |   38 +
 FFmpegInterop/CLR/FFmpegInterop.CLR/Stdafx.cpp     |    5 +
 FFmpegInterop/CLR/FFmpegInterop.CLR/Stdafx.h       |   13 +
 .../CLR/FFmpegInterop.CLR/TestNativeClass.cpp      |   17 +
 .../CLR/FFmpegInterop.CLR/TestNativeClass.h        |   13 +
 .../UncompressedAudioSampleProvider.cpp            |  149 ++
 .../UncompressedAudioSampleProvider.h              |   48 +
 .../UncompressedSampleProvider.cpp                 |  123 ++
 .../FFmpegInterop.CLR/UncompressedSampleProvider.h |   45 +
 .../UncompressedVideoSampleProvider.cpp            |  157 +++
 .../UncompressedVideoSampleProvider.h              |   52 +
 .../FFmpegInterop.Shared2.vcxitems                 |   46 +
 .../FFmpegInterop.Shared2.vcxitems.filters         |   30 +
 FFmpegInterop/CLR/FFmpegInterop.Shared2/pch.cpp    |   19 +
 FFmpegInterop/CLR/FFmpegInterop.Shared2/pch.h      |   29 +
 FFmpegInterop/Source/FFmpegInteropMSS.cpp          | 1481 +++++++++++---------
 FFmpegInterop/Source/FFmpegInteropMSS.h            |    6 +
 FFmpegWin10.sln                                    |   52 +-
 FFmpegWin8.1.sln                                   |   77 +-
 .../MediaPlayerCS.Windows/MainPage.xaml.cs         |   14 +-
 .../MediaPlayerCS.Windows.csproj                   |    4 +
 TestConsole/App.config                             |    6 +
 TestConsole/Program.cs                             |   32 +
 TestConsole/Properties/AssemblyInfo.cs             |   36 +
 TestConsole/TestConsole.csproj                     |  117 ++
 46 files changed, 4307 insertions(+), 694 deletions(-)
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/AssemblyInfo.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.vcxproj
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.vcxproj.filters
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropLogging.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropLogging.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropMSS.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropMSS.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegReader.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegReader.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/H264AVCSampleProvider.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/H264AVCSampleProvider.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/H264SampleProvider.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/H264SampleProvider.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/ILogProvider.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/MediaSampleProvider.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/MediaSampleProvider.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/MediaThumbnailData.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/MyMediaStreamSample.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/MyMediaStreamSample.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/ReadMe.txt
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/Stdafx.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/Stdafx.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/TestNativeClass.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/TestNativeClass.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedAudioSampleProvider.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedAudioSampleProvider.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedSampleProvider.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedSampleProvider.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedVideoSampleProvider.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedVideoSampleProvider.h
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.Shared2/FFmpegInterop.Shared2.vcxitems
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.Shared2/FFmpegInterop.Shared2.vcxitems.filters
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.Shared2/pch.cpp
 create mode 100644 FFmpegInterop/CLR/FFmpegInterop.Shared2/pch.h
 create mode 100644 TestConsole/App.config
 create mode 100644 TestConsole/Program.cs
 create mode 100644 TestConsole/Properties/AssemblyInfo.cs
 create mode 100644 TestConsole/TestConsole.csproj

diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/AssemblyInfo.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/AssemblyInfo.cpp
new file mode 100644
index 0000000..e2d3cda
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/AssemblyInfo.cpp
@@ -0,0 +1,38 @@
+#include "stdafx.h"
+
+using namespace System;
+using namespace System::Reflection;
+using namespace System::Runtime::CompilerServices;
+using namespace System::Runtime::InteropServices;
+using namespace System::Security::Permissions;
+
+//
+// General Information about an assembly is controlled through the following
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+//
+[assembly:AssemblyTitleAttribute(L"FFmpegInteropCLR")];
+[assembly:AssemblyDescriptionAttribute(L"")];
+[assembly:AssemblyConfigurationAttribute(L"")];
+[assembly:AssemblyCompanyAttribute(L"")];
+[assembly:AssemblyProductAttribute(L"FFmpegInteropCLR")];
+[assembly:AssemblyCopyrightAttribute(L"Copyright (c)  2017")];
+[assembly:AssemblyTrademarkAttribute(L"")];
+[assembly:AssemblyCultureAttribute(L"")];
+
+//
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version
+//      Build Number
+//      Revision
+//
+// You can specify all the value or you can default the Revision and Build Numbers
+// by using the '*' as shown below:
+
+[assembly:AssemblyVersionAttribute("1.0.*")];
+
+[assembly:ComVisible(false)];
+
+[assembly:CLSCompliantAttribute(true)];
\ No newline at end of file
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.cpp
new file mode 100644
index 0000000..05f9f3d
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.cpp
@@ -0,0 +1,6 @@
+// This is the main DLL file.
+
+#include "stdafx.h"
+
+#include "FFmpegInterop.CLR.h"
+
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.h
new file mode 100644
index 0000000..fdcc425
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.h
@@ -0,0 +1,13 @@
+// FFmpegInterop.CLR.h
+
+#pragma once
+
+using namespace System;
+
+namespace FFmpegInteropCLR {
+
+	public ref class Class1
+	{
+		// TODO: Add your methods for this class here.
+	};
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.vcxproj b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.vcxproj
new file mode 100644
index 0000000..ac242f1
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.vcxproj
@@ -0,0 +1,178 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}</ProjectGuid>
+    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
+    <Keyword>ManagedCProj</Keyword>
+    <RootNamespace>FFmpegInteropCLR</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0.14393.0</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CLRSupport>true</CLRSupport>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>true</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CLRSupport>true</CLRSupport>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CLRSupport>true</CLRSupport>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
+    <ConfigurationType>DynamicLibrary</ConfigurationType>
+    <UseDebugLibraries>false</UseDebugLibraries>
+    <PlatformToolset>v140</PlatformToolset>
+    <CLRSupport>true</CLRSupport>
+    <CharacterSet>Unicode</CharacterSet>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings">
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <LinkIncremental>true</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <LinkIncremental>false</LinkIncremental>
+  </PropertyGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <AdditionalIncludeDirectories>$(SolutionDir)ffmpeg\Build\Windows10\$(PlatformTarget)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>avcodec.lib;avdevice.lib;avfilter.lib;avformat.lib;avutil.lib;swresample.lib;swscale.lib;shcore.lib;runtimeobject.lib;mfuuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
+      <AdditionalLibraryDirectories>$(SolutionDir)ffmpeg\Build\Windows10\$(PlatformTarget)\bin;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <Optimization>Disabled</Optimization>
+      <PreprocessorDefinitions>WIN32;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <AdditionalIncludeDirectories>$(SolutionDir)ffmpeg\Build\Windows10\$(PlatformTarget)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>avcodec.lib;avdevice.lib;avfilter.lib;avformat.lib;avutil.lib;swresample.lib;swscale.lib;shcore.lib;runtimeobject.lib;mfuuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
+      <AdditionalLibraryDirectories>$(SolutionDir)ffmpeg\Build\Windows10\$(PlatformTarget)\bin;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PreprocessorDefinitions>WIN32;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <AdditionalIncludeDirectories>$(SolutionDir)ffmpeg\Build\Windows10\$(PlatformTarget)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>avcodec.lib;avdevice.lib;avfilter.lib;avformat.lib;avutil.lib;swresample.lib;swscale.lib;shcore.lib;runtimeobject.lib;mfuuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
+      <AdditionalLibraryDirectories>$(SolutionDir)ffmpeg\Build\Windows10\$(PlatformTarget)\bin;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
+    <ClCompile>
+      <WarningLevel>Level3</WarningLevel>
+      <PreprocessorDefinitions>WIN32;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <PrecompiledHeader>Use</PrecompiledHeader>
+      <AdditionalIncludeDirectories>$(SolutionDir)ffmpeg\Build\Windows10\$(PlatformTarget)\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+    </ClCompile>
+    <Link>
+      <GenerateDebugInformation>true</GenerateDebugInformation>
+      <AdditionalDependencies>avcodec.lib;avdevice.lib;avfilter.lib;avformat.lib;avutil.lib;swresample.lib;swscale.lib;shcore.lib;runtimeobject.lib;mfuuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
+      <IgnoreAllDefaultLibraries>false</IgnoreAllDefaultLibraries>
+      <AdditionalLibraryDirectories>$(SolutionDir)ffmpeg\Build\Windows10\$(PlatformTarget)\bin;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <Reference Include="System" />
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="FFmpegInterop.CLR.h" />
+    <ClInclude Include="FFmpegInteropMSS.h" />
+    <ClInclude Include="FFmpegReader.h" />
+    <ClInclude Include="MediaSampleProvider.h" />
+    <ClInclude Include="MyMediaStreamSample.h" />
+    <ClInclude Include="Stdafx.h" />
+    <ClInclude Include="TestNativeClass.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="AssemblyInfo.cpp" />
+    <ClCompile Include="FFmpegInterop.CLR.cpp" />
+    <ClCompile Include="FFmpegInteropMSS.cpp" />
+    <ClCompile Include="FFmpegReader.cpp" />
+    <ClCompile Include="MediaSampleProvider.cpp" />
+    <ClCompile Include="MyMediaStreamSample.cpp" />
+    <ClCompile Include="Stdafx.cpp">
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
+      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="TestNativeClass.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <Text Include="ReadMe.txt" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets">
+  </ImportGroup>
+</Project>
\ No newline at end of file
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.vcxproj.filters b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.vcxproj.filters
new file mode 100644
index 0000000..c7c66da
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInterop.CLR.vcxproj.filters
@@ -0,0 +1,65 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="FFmpegInterop.CLR.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="Stdafx.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="FFmpegInteropMSS.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="FFmpegReader.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="MediaSampleProvider.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="MyMediaStreamSample.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="TestNativeClass.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="FFmpegInterop.CLR.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="AssemblyInfo.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="Stdafx.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="FFmpegInteropMSS.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="FFmpegReader.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="MediaSampleProvider.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="MyMediaStreamSample.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="TestNativeClass.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <Text Include="ReadMe.txt" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropLogging.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropLogging.cpp
new file mode 100644
index 0000000..abf0979
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropLogging.cpp
@@ -0,0 +1,68 @@
+
+//*****************************************************************************
+//
+//	Copyright 2017 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#include "pch.h"
+#include "FFmpegInteropLogging.h"
+
+using namespace FFmpegInterop;
+
+extern "C"
+{
+#include <libavutil/log.h>
+}
+
+ILogProvider^ FFmpegInteropLogging::s_pLogProvider = nullptr;
+
+FFmpegInteropLogging::FFmpegInteropLogging()
+{
+}
+
+void FFmpegInteropLogging::SetLogLevel(LogLevel level)
+{
+	av_log_set_level((int)level);
+}
+
+void FFmpegInteropLogging::SetLogProvider(ILogProvider^ logProvider)
+{
+	s_pLogProvider = logProvider;
+	av_log_set_callback([](void*avcl, int level, const char *fmt, va_list vl)->void
+	{
+		if (level <= av_log_get_level())
+		{
+			if (s_pLogProvider != nullptr)
+			{
+				char pLine[1000];
+				int printPrefix = 1;
+				av_log_format_line(avcl, level, fmt, vl, pLine, sizeof(pLine), &printPrefix);
+
+				wchar_t wLine[sizeof(pLine)];
+				if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pLine, -1, wLine, sizeof(pLine)) != 0)
+				{
+					s_pLogProvider->Log((LogLevel)level, ref new String(wLine));
+				}
+			}
+		}
+	});
+}
+
+void FFmpegInteropLogging::SetDefaultLogProvider()
+{
+	av_log_set_callback(av_log_default_callback);
+}
+
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropLogging.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropLogging.h
new file mode 100644
index 0000000..0ef9481
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropLogging.h
@@ -0,0 +1,37 @@
+//*****************************************************************************
+//
+//	Copyright 2017 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#pragma once
+#include "ILogProvider.h"
+
+namespace FFmpegInterop
+{
+	public ref class FFmpegInteropLogging sealed
+	{
+	public:
+		static void SetLogLevel(LogLevel level);
+		static void SetLogProvider(ILogProvider^ logProvider);
+		static void SetDefaultLogProvider();
+
+	private:
+		FFmpegInteropLogging();
+
+		static ILogProvider^ s_pLogProvider;
+	};
+}
+
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropMSS.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropMSS.cpp
new file mode 100644
index 0000000..93face9
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropMSS.cpp
@@ -0,0 +1,936 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#include "stdafx.h"
+#include <msclr/lock.h>
+#include <msclr/marshal_cppstd.h>
+#include "FFmpegInteropMSS.h"
+#include "MediaSampleProvider.h"
+
+#include "TestNativeClass.h"
+
+//#include "H264AVCSampleProvider.h"
+//#include "H264SampleProvider.h"
+//#include "UncompressedAudioSampleProvider.h"
+//#include "UncompressedVideoSampleProvider.h"
+//#include "shcore.h"
+
+extern "C"
+{
+#include <libavutil/imgutils.h>
+}
+
+//using namespace concurrency;
+using namespace FFmpegInterop;
+//using namespace Platform;
+//using namespace Windows::Storage::Streams;
+//using namespace Windows::Media::MediaProperties;
+
+// Size of the buffer when reading a stream
+const int FILESTREAMBUFFERSZ = 16384;
+
+// Static functions passed to FFmpeg for stream interop
+static int FileStreamRead(void* ptr, uint8_t* buf, int bufSize);
+static int64_t FileStreamSeek(void* ptr, int64_t pos, int whence);
+
+// Initialize an FFmpegInteropObject
+FFmpegInteropMSS::FFmpegInteropMSS()
+	: avDict(nullptr)
+	, avIOCtx(nullptr)
+	, avFormatCtx(nullptr)
+	, avAudioCodecCtx(nullptr)
+	, avVideoCodecCtx(nullptr)
+	, audioStreamIndex(AVERROR_STREAM_NOT_FOUND)
+	, videoStreamIndex(AVERROR_STREAM_NOT_FOUND)
+	, thumbnailStreamIndex(AVERROR_STREAM_NOT_FOUND)
+	, fileStreamData(nullptr)
+	, fileStreamBuffer(nullptr)
+{
+	av_register_all();
+}
+
+FFmpegInteropMSS::~FFmpegInteropMSS()
+{
+	//mutexGuard.lock();
+	msclr::lock lockGuard(this);
+	//if (mss)
+	//{
+	//	mss->Starting -= startingRequestedToken;
+	//	mss->SampleRequested -= sampleRequestedToken;
+	//	mss = nullptr;
+	//}
+
+	// Clear our data
+	audioSampleProvider = nullptr;
+	videoSampleProvider = nullptr;
+
+	if (m_pReader != nullptr)
+	{
+		m_pReader->SetAudioStream(AVERROR_STREAM_NOT_FOUND, nullptr);
+		m_pReader->SetVideoStream(AVERROR_STREAM_NOT_FOUND, nullptr);
+		m_pReader = nullptr;
+	}
+
+	avcodec_close(avVideoCodecCtx);
+	avcodec_close(avAudioCodecCtx);
+	pin_ptr<AVFormatContext*> avFormatCtxPtr = &avFormatCtx;
+	avformat_close_input(avFormatCtxPtr);
+	av_free(avIOCtx);
+	pin_ptr<AVDictionary*> avDictPtr = &avDict;
+	av_dict_free(avDictPtr);
+	
+	if (fileStreamData != nullptr)
+	{
+		fileStreamData->Release();
+	}
+	//mutexGuard.unlock();
+}
+
+//FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss)
+//{
+//	auto interopMSS = ref new FFmpegInteropMSS();
+//	if (FAILED(interopMSS->CreateMediaStreamSource(stream, forceAudioDecode, forceVideoDecode, ffmpegOptions, mss)))
+//	{
+//		// We failed to initialize, clear the variable to return failure
+//		interopMSS = nullptr;
+//	}
+//
+//	return interopMSS;
+//}
+
+//HRESULT FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream2(IStream* stream, bool forceAudioDecode, bool forceVideoDecode)
+//{
+//	return S_OK;
+//}
+
+
+
+FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(System::Runtime::InteropServices::ComTypes::IStream ^stream, bool forceAudioDecode, bool forceVideoDecode /*, PropertySet^ ffmpegOptions, MediaStreamSource^ mss*/)
+//FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(CComPtr<IStream> stream, bool forceAudioDecode, bool forceVideoDecode /*, PropertySet^ ffmpegOptions, MediaStreamSource^ mss*/)
+{
+	//TestNativeClass::Test1(stream);
+
+	FFmpegInteropMSS^ interopMSS = nullptr;
+
+	System::IntPtr intPtr = System::Runtime::InteropServices::Marshal::GetIUnknownForObject(stream);
+	IUnknown* unknownPtr = static_cast<IUnknown*>(static_cast<void*>(intPtr));
+	IStream* streamPtr;
+	HRESULT hr = unknownPtr->QueryInterface(IID_PPV_ARGS(&streamPtr));
+	if (SUCCEEDED(hr))
+	{
+		interopMSS = gcnew FFmpegInteropMSS();
+		if (FAILED(interopMSS->CreateMediaStreamSource(streamPtr, forceAudioDecode, forceVideoDecode /*, ffmpegOptions, mss*/)))
+		{
+			// We failed to initialize, clear the variable to return failure
+			interopMSS = nullptr;
+		}
+	}
+
+	return interopMSS;
+}
+
+
+//FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(System::IO::Stream^ stream, bool forceAudioDecode, bool forceVideoDecode /*, PropertySet^ ffmpegOptions, MediaStreamSource^ mss*/)
+//{
+//	return nullptr;
+//}
+
+
+//FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions)
+//{
+//	return CreateFFmpegInteropMSSFromStream(stream, forceAudioDecode, forceVideoDecode, nullptr, nullptr);
+//}
+
+//FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(IStream *stream, bool forceAudioDecode, bool forceVideoDecode)
+//{
+//	return CreateFFmpegInteropMSSFromStream(stream, forceAudioDecode, forceVideoDecode, nullptr);
+//}
+
+FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromUri(String^ uri, bool forceAudioDecode, bool forceVideoDecode /*, PropertySet^ ffmpegOptions*/)
+{
+	auto interopMSS = gcnew FFmpegInteropMSS();
+	if (FAILED(interopMSS->CreateMediaStreamSource(uri, forceAudioDecode, forceVideoDecode /*, ffmpegOptions*/)))
+	{
+		// We failed to initialize, clear the variable to return failure
+		interopMSS = nullptr;
+	}
+
+	return interopMSS;
+}
+
+//FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromUri(String^ uri, bool forceAudioDecode, bool forceVideoDecode)
+//{
+//	return CreateFFmpegInteropMSSFromUri(uri, forceAudioDecode, forceVideoDecode, nullptr);
+//}
+
+//MediaStreamSource^ FFmpegInteropMSS::GetMediaStreamSource()
+//{
+//	return mss;
+//}
+
+HRESULT FFmpegInteropMSS::CreateMediaStreamSource(String^ uri, bool forceAudioDecode, bool forceVideoDecode /*, PropertySet^ ffmpegOptions*/)
+{
+	HRESULT hr = S_OK;
+	const char* charStr = nullptr;
+	if (!uri)
+	{
+		hr = E_INVALIDARG;
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		avFormatCtx = avformat_alloc_context();
+		if (avFormatCtx == nullptr)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	//if (SUCCEEDED(hr))
+	//{
+	//	// Populate AVDictionary avDict based on PropertySet ffmpegOptions. List of options can be found in https://www.ffmpeg.org/ffmpeg-protocols.html
+	//	hr = ParseOptions(ffmpegOptions);
+	//}
+
+	if (SUCCEEDED(hr))
+	{
+		msclr::interop::marshal_context context;		
+		std::string uriA = context.marshal_as<std::string>(uri);
+		//std::wstring uriW(uri-> ->Begin());
+		//std::string uriA(uriW.begin(), uriW.end());
+		charStr = uriA.c_str();
+
+		// Open media in the given URI using the specified options
+		pin_ptr<AVFormatContext*> avFormatCtxPtr = &avFormatCtx;
+		pin_ptr<AVDictionary*> avDictPtr = &avDict;
+		if (avformat_open_input(avFormatCtxPtr, charStr, NULL, avDictPtr) < 0)
+		{
+			hr = E_FAIL; // Error opening file
+		}
+
+		// avDict is not NULL only when there is an issue with the given ffmpegOptions such as invalid key, value type etc. Iterate through it to see which one is causing the issue.
+		if (avDict != nullptr)
+		{
+			DebugMessage(L"Invalid FFmpeg option(s)");
+			av_dict_free(avDictPtr);
+			avDict = nullptr;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		//this->mss = nullptr;
+		hr = InitFFmpegContext(forceAudioDecode, forceVideoDecode);
+	}
+
+	return hr;
+}
+
+HRESULT FFmpegInteropMSS::CreateMediaStreamSource(IStream *stream, bool forceAudioDecode, bool forceVideoDecode /*, PropertySet^ ffmpegOptions, MediaStreamSource^ mss*/)
+{
+	HRESULT hr = S_OK;
+	if (!stream)
+	{
+		hr = E_INVALIDARG;
+	}
+
+	//if (SUCCEEDED(hr))
+	//{
+	//	// Convert asynchronous IRandomAccessStream to synchronous IStream. This API requires shcore.h and shcore.lib
+	//	hr = CreateStreamOverRandomAccessStream(reinterpret_cast<IUnknown*>(stream), IID_PPV_ARGS(&fileStreamData));
+	//}
+
+	fileStreamData = stream;
+
+	if (SUCCEEDED(hr))
+	{
+		// Setup FFmpeg custom IO to access file as stream. This is necessary when accessing any file outside of app installation directory and appdata folder.
+		// Credit to Philipp Sch http://www.codeproject.com/Tips/489450/Creating-Custom-FFmpeg-IO-Context
+		fileStreamBuffer = (unsigned char*)av_malloc(FILESTREAMBUFFERSZ);
+		if (fileStreamBuffer == nullptr)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		avIOCtx = avio_alloc_context(fileStreamBuffer, FILESTREAMBUFFERSZ, 0, fileStreamData, FileStreamRead, 0, FileStreamSeek);
+		if (avIOCtx == nullptr)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		avFormatCtx = avformat_alloc_context();
+		if (avFormatCtx == nullptr)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	// TODO: fix
+	//if (SUCCEEDED(hr))
+	//{
+	//	// Populate AVDictionary avDict based on PropertySet ffmpegOptions. List of options can be found in https://www.ffmpeg.org/ffmpeg-protocols.html
+	//	hr = ParseOptions(ffmpegOptions);
+	//}
+
+	if (SUCCEEDED(hr))
+	{
+		avFormatCtx->pb = avIOCtx;
+		avFormatCtx->flags |= AVFMT_FLAG_CUSTOM_IO;
+
+		// Open media file using custom IO setup above instead of using file name. Opening a file using file name will invoke fopen C API call that only have
+		// access within the app installation directory and appdata folder. Custom IO allows access to file selected using FilePicker dialog.
+		pin_ptr<AVFormatContext*> avFormatCtxPtr = &avFormatCtx;
+		pin_ptr<AVDictionary*> avDictPtr = &avDict;
+		if (avformat_open_input(avFormatCtxPtr, "", NULL, avDictPtr) < 0)
+		{
+			hr = E_FAIL; // Error opening file
+		}
+
+		// avDict is not NULL only when there is an issue with the given ffmpegOptions such as invalid key, value type etc. Iterate through it to see which one is causing the issue.
+		if (avDict != nullptr)
+		{
+			DebugMessage(L"Invalid FFmpeg option(s)");
+			av_dict_free(avDictPtr);
+			avDict = nullptr;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		//this->mss = mss;
+		hr = InitFFmpegContext(forceAudioDecode, forceVideoDecode);
+	}
+
+	return hr;
+}
+
+//HRESULT FFmpegInteropMSS::CreateMediaStreamSource(IStream* stream, bool forceAudioDecode, bool forceVideoDecode /*, PropertySet^ ffmpegOptions, MediaStreamSource^ mss*/)
+//{
+//	HRESULT hr = S_OK;
+//	if (!stream)
+//	{
+//		hr = E_INVALIDARG;
+//	}
+//
+//	//if (SUCCEEDED(hr))
+//	//{
+//	//	// Convert asynchronous IRandomAccessStream to synchronous IStream. This API requires shcore.h and shcore.lib
+//	//	hr = CreateStreamOverRandomAccessStream(reinterpret_cast<IUnknown*>(stream), IID_PPV_ARGS(&fileStreamData));
+//	//}
+//
+//	fileStreamData = stream;
+//
+//	if (SUCCEEDED(hr))
+//	{
+//		// Setup FFmpeg custom IO to access file as stream. This is necessary when accessing any file outside of app installation directory and appdata folder.
+//		// Credit to Philipp Sch http://www.codeproject.com/Tips/489450/Creating-Custom-FFmpeg-IO-Context
+//		fileStreamBuffer = (unsigned char*)av_malloc(FILESTREAMBUFFERSZ);
+//		if (fileStreamBuffer == nullptr)
+//		{
+//			hr = E_OUTOFMEMORY;
+//		}
+//	}
+//
+//	if (SUCCEEDED(hr))
+//	{
+//		avIOCtx = avio_alloc_context(fileStreamBuffer, FILESTREAMBUFFERSZ, 0, fileStreamData, FileStreamRead, 0, FileStreamSeek);
+//		if (avIOCtx == nullptr)
+//		{
+//			hr = E_OUTOFMEMORY;
+//		}
+//	}
+//
+//	if (SUCCEEDED(hr))
+//	{
+//		avFormatCtx = avformat_alloc_context();
+//		if (avFormatCtx == nullptr)
+//		{
+//			hr = E_OUTOFMEMORY;
+//		}
+//	}
+//
+//	//if (SUCCEEDED(hr))
+//	//{
+//	//	// Populate AVDictionary avDict based on PropertySet ffmpegOptions. List of options can be found in https://www.ffmpeg.org/ffmpeg-protocols.html
+//	//	hr = ParseOptions(ffmpegOptions);
+//	//}
+//
+//	if (SUCCEEDED(hr))
+//	{
+//		avFormatCtx->pb = avIOCtx;
+//		avFormatCtx->flags |= AVFMT_FLAG_CUSTOM_IO;
+//
+//		// Open media file using custom IO setup above instead of using file name. Opening a file using file name will invoke fopen C API call that only have
+//		// access within the app installation directory and appdata folder. Custom IO allows access to file selected using FilePicker dialog.
+//		pin_ptr<AVFormatContext*> avFormatCtxPtr = &avFormatCtx;
+//		pin_ptr<AVDictionary*> avDictPtr = &avDict;
+//		if (avformat_open_input(avFormatCtxPtr, "", NULL, avDictPtr) < 0)
+//		{
+//			hr = E_FAIL; // Error opening file
+//		}
+//
+//		// avDict is not NULL only when there is an issue with the given ffmpegOptions such as invalid key, value type etc. Iterate through it to see which one is causing the issue.
+//		if (avDict != nullptr)
+//		{
+//			DebugMessage(L"Invalid FFmpeg option(s)");
+//			av_dict_free(avDictPtr);
+//			avDict = nullptr;
+//		}
+//	}
+//
+//	if (SUCCEEDED(hr))
+//	{
+//		//this->mss = mss;
+//		hr = InitFFmpegContext(forceAudioDecode, forceVideoDecode);
+//	}
+//
+//	return hr;
+//}
+
+
+HRESULT FFmpegInteropMSS::InitFFmpegContext(bool forceAudioDecode, bool forceVideoDecode)
+{
+	HRESULT hr = S_OK;
+
+	if (SUCCEEDED(hr))
+	{
+		if (avformat_find_stream_info(avFormatCtx, NULL) < 0)
+		{
+			hr = E_FAIL; // Error finding info
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		m_pReader = gcnew FFmpegReader(avFormatCtx);
+		if (m_pReader == nullptr)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Find the audio stream and its decoder
+		AVCodec* avAudioCodec = nullptr;
+		audioStreamIndex = av_find_best_stream(avFormatCtx, AVMEDIA_TYPE_AUDIO, -1, -1, &avAudioCodec, 0);
+		if (audioStreamIndex != AVERROR_STREAM_NOT_FOUND && avAudioCodec)
+		{
+			// allocate a new decoding context
+			avAudioCodecCtx = avcodec_alloc_context3(avAudioCodec);
+			if (!avAudioCodecCtx)
+			{
+				hr = E_OUTOFMEMORY;
+				DebugMessage(L"Could not allocate a decoding context\n");
+				pin_ptr<AVFormatContext*> avFormatCtxPtr = &avFormatCtx;
+				avformat_close_input(avFormatCtxPtr);
+			}
+
+			if (SUCCEEDED(hr))
+			{
+				// initialize the stream parameters with demuxer information
+				if (avcodec_parameters_to_context(avAudioCodecCtx, avFormatCtx->streams[audioStreamIndex]->codecpar) < 0)
+				{
+					hr = E_FAIL;
+					pin_ptr<AVFormatContext*> avFormatCtxPtr = &avFormatCtx;
+					avformat_close_input(avFormatCtxPtr);
+					pin_ptr<AVCodecContext*> avAudioCodecCtxPtr = &avAudioCodecCtx;
+					avcodec_free_context(avAudioCodecCtxPtr);
+				}
+
+				if (SUCCEEDED(hr))
+				{
+					if (avcodec_open2(avAudioCodecCtx, avAudioCodec, NULL) < 0)
+					{
+						avAudioCodecCtx = nullptr;
+						hr = E_FAIL;
+					}
+					else
+					{
+						// Detect audio format and create audio stream descriptor accordingly
+						// TODO: fix stream descriptor
+						//hr = CreateAudioStreamDescriptor(forceAudioDecode);
+						//if (SUCCEEDED(hr))
+						//{
+							hr = audioSampleProvider->AllocateResources();
+							if (SUCCEEDED(hr))
+							{
+								m_pReader->SetAudioStream(audioStreamIndex, audioSampleProvider);
+							}
+						//}
+
+						if (SUCCEEDED(hr))
+						{
+							// Convert audio codec name for property
+							hr = ConvertCodecName(avAudioCodec->name, audioCodecName);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Find the video stream and its decoder
+		AVCodec* avVideoCodec = nullptr;
+		videoStreamIndex = av_find_best_stream(avFormatCtx, AVMEDIA_TYPE_VIDEO, -1, -1, &avVideoCodec, 0);
+		if (videoStreamIndex != AVERROR_STREAM_NOT_FOUND && avVideoCodec)
+		{
+			// FFmpeg identifies album/cover art from a music file as a video stream
+			// Avoid creating unnecessarily video stream from this album/cover art
+			if (avFormatCtx->streams[videoStreamIndex]->disposition == AV_DISPOSITION_ATTACHED_PIC)
+			{
+				thumbnailStreamIndex = videoStreamIndex;
+				videoStreamIndex = AVERROR_STREAM_NOT_FOUND;
+				avVideoCodec = nullptr;
+			}
+			else
+			{
+				thumbnailStreamIndex = AVERROR_STREAM_NOT_FOUND;
+				AVDictionaryEntry *rotate_tag = av_dict_get(avFormatCtx->streams[videoStreamIndex]->metadata, "rotate", NULL, 0);
+				if (rotate_tag != NULL)
+				{
+					rotateVideo = true;
+					rotationAngle = atoi(rotate_tag->value);
+				}
+				else
+				{
+					rotateVideo = false;
+				}
+				// allocate a new decoding context
+				avVideoCodecCtx = avcodec_alloc_context3(avVideoCodec);
+				if (!avVideoCodecCtx)
+				{
+					DebugMessage(L"Could not allocate a decoding context\n");
+					pin_ptr<AVFormatContext*> avFormatCtxPtr = &avFormatCtx;
+					avformat_close_input(avFormatCtxPtr);
+					hr = E_OUTOFMEMORY;
+				}
+
+				if (SUCCEEDED(hr))
+				{
+					// initialize the stream parameters with demuxer information
+					if (avcodec_parameters_to_context(avVideoCodecCtx, avFormatCtx->streams[videoStreamIndex]->codecpar) < 0)
+					{
+						pin_ptr<AVFormatContext*> avFormatCtxPtr = &avFormatCtx;
+						avformat_close_input(avFormatCtxPtr);
+						pin_ptr<AVCodecContext*> avVideoCodecCtxPtr = &avVideoCodecCtx;
+						avcodec_free_context(avVideoCodecCtxPtr);
+						hr = E_FAIL;
+					}
+				}
+
+				if (SUCCEEDED(hr))
+				{
+					if (avcodec_open2(avVideoCodecCtx, avVideoCodec, NULL) < 0)
+					{
+						avVideoCodecCtx = nullptr;
+						hr = E_FAIL; // Cannot open the video codec
+					}
+					else
+					{
+						// Detect video format and create video stream descriptor accordingly
+						// TODO: fix video stream descriptor
+						//hr = CreateVideoStreamDescriptor(forceVideoDecode);
+						//if (SUCCEEDED(hr))
+						//{
+							hr = videoSampleProvider->AllocateResources();
+							if (SUCCEEDED(hr))
+							{
+								m_pReader->SetVideoStream(videoStreamIndex, videoSampleProvider);
+							}
+						//}
+
+						if (SUCCEEDED(hr))
+						{
+							// Convert video codec name for property
+							hr = ConvertCodecName(avVideoCodec->name, videoCodecName);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Convert media duration from AV_TIME_BASE to TimeSpan unit
+		//mediaDuration = { LONGLONG(avFormatCtx->duration * 10000000 / double(AV_TIME_BASE)) };
+
+		// TODO: fix
+	//	if (audioStreamDescriptor)
+	//	{
+	//		if (videoStreamDescriptor)
+	//		{
+	//			if (mss)
+	//			{
+	//				mss->AddStreamDescriptor(videoStreamDescriptor);
+	//				mss->AddStreamDescriptor(audioStreamDescriptor);
+	//			}
+	//			else
+	//			{
+	//				mss = ref new MediaStreamSource(videoStreamDescriptor, audioStreamDescriptor);
+	//			}
+	//		}
+	//		else
+	//		{
+	//			if (mss)
+	//			{
+	//				mss->AddStreamDescriptor(audioStreamDescriptor);
+	//			}
+	//			else
+	//			{
+	//				mss = ref new MediaStreamSource(audioStreamDescriptor);
+	//			}
+	//		}
+	//	}
+	//	else if (videoStreamDescriptor)
+	//	{
+	//		if (mss)
+	//		{
+	//			mss->AddStreamDescriptor(videoStreamDescriptor);
+	//		}
+	//		else
+	//		{
+	//			mss = ref new MediaStreamSource(videoStreamDescriptor);
+	//		}
+	//	}
+	//	if (mss)
+	//	{
+	//		if (mediaDuration.Duration > 0)
+	//		{
+	//			mss->Duration = mediaDuration;
+	//			mss->CanSeek = true;
+	//		}
+	//		else
+	//		{
+	//			// Set buffer time to 0 for realtime streaming to reduce latency
+	//			mss->BufferTime = { 0 };
+	//		}
+
+	//		startingRequestedToken = mss->Starting += ref new TypedEventHandler<MediaStreamSource ^, MediaStreamSourceStartingEventArgs ^>(this, &FFmpegInteropMSS::OnStarting);
+	//		sampleRequestedToken = mss->SampleRequested += ref new TypedEventHandler<MediaStreamSource ^, MediaStreamSourceSampleRequestedEventArgs ^>(this, &FFmpegInteropMSS::OnSampleRequested);
+	//	}
+	//	else
+	//	{
+	//		hr = E_OUTOFMEMORY;
+	//	}
+	}
+
+	return hr;
+}
+
+//MediaThumbnailData ^ FFmpegInterop::FFmpegInteropMSS::ExtractThumbnail()
+//{
+//	if (thumbnailStreamIndex != AVERROR_STREAM_NOT_FOUND)
+//	{
+//		// FFmpeg identifies album/cover art from a music file as a video stream
+//		// Avoid creating unnecessarily video stream from this album/cover art
+//		if (avFormatCtx->streams[thumbnailStreamIndex]->disposition == AV_DISPOSITION_ATTACHED_PIC)
+//		{
+//			auto imageStream = avFormatCtx->streams[thumbnailStreamIndex];
+//			//save album art to file.
+//			String^ extension = ".jpeg";
+//			switch (imageStream->codecpar->codec_id)
+//			{
+//			case AV_CODEC_ID_MJPEG:
+//			case AV_CODEC_ID_MJPEGB:
+//			case AV_CODEC_ID_JPEG2000:
+//			case AV_CODEC_ID_JPEGLS: extension = ".jpeg"; break;
+//			case AV_CODEC_ID_PNG: extension = ".png"; break;
+//			case AV_CODEC_ID_BMP: extension = ".bmp"; break;
+//			}
+//
+//
+//			auto vector = ref new Array<uint8_t>(imageStream->attached_pic.data, imageStream->attached_pic.size);
+//			DataWriter^ writer = ref new DataWriter();
+//			writer->WriteBytes(vector);
+//
+//			return (ref new MediaThumbnailData(writer->DetachBuffer(), extension));
+//		}
+//	}
+//
+//	return nullptr;
+//}
+
+HRESULT FFmpegInteropMSS::ConvertCodecName(const char* codecName, String^ %outputCodecName)
+{
+	HRESULT hr = S_OK;
+
+	// Convert codec name from const char* to Platform::String
+	auto codecNameChars = codecName;
+	size_t newsize = strlen(codecNameChars) + 1;
+	wchar_t * wcstring = new(std::nothrow) wchar_t[newsize];
+	if (wcstring == nullptr)
+	{
+		hr = E_OUTOFMEMORY;
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		size_t convertedChars = 0;
+		mbstowcs_s(&convertedChars, wcstring, newsize, codecNameChars, _TRUNCATE);
+		outputCodecName = gcnew System::String(wcstring);
+		delete[] wcstring;
+	}
+
+	return hr;
+}
+
+// TODO: fix
+//HRESULT FFmpegInteropMSS::CreateAudioStreamDescriptor(bool forceAudioDecode)
+//{
+//	if (avAudioCodecCtx->codec_id == AV_CODEC_ID_AAC && !forceAudioDecode)
+//	{
+//		if (avAudioCodecCtx->extradata_size == 0)
+//		{
+//			audioStreamDescriptor = ref new AudioStreamDescriptor(AudioEncodingProperties::CreateAacAdts(avAudioCodecCtx->sample_rate, avAudioCodecCtx->channels, (unsigned int)avAudioCodecCtx->bit_rate));
+//		}
+//		else
+//		{
+//			audioStreamDescriptor = ref new AudioStreamDescriptor(AudioEncodingProperties::CreateAac(avAudioCodecCtx->sample_rate, avAudioCodecCtx->channels, (unsigned int)avAudioCodecCtx->bit_rate));
+//		}
+//		audioSampleProvider = ref new MediaSampleProvider(m_pReader, avFormatCtx, avAudioCodecCtx);
+//	}
+//	else if (avAudioCodecCtx->codec_id == AV_CODEC_ID_MP3 && !forceAudioDecode)
+//	{
+//		audioStreamDescriptor = ref new AudioStreamDescriptor(AudioEncodingProperties::CreateMp3(avAudioCodecCtx->sample_rate, avAudioCodecCtx->channels, (unsigned int)avAudioCodecCtx->bit_rate));
+//		audioSampleProvider = ref new MediaSampleProvider(m_pReader, avFormatCtx, avAudioCodecCtx);
+//	}
+//	else
+//	{
+//		// We always convert to 16-bit audio so set the size here
+//		audioStreamDescriptor = ref new AudioStreamDescriptor(AudioEncodingProperties::CreatePcm(avAudioCodecCtx->sample_rate, avAudioCodecCtx->channels, 16));
+//		audioSampleProvider = ref new UncompressedAudioSampleProvider(m_pReader, avFormatCtx, avAudioCodecCtx);
+//	}
+//
+//	return (audioStreamDescriptor != nullptr && audioSampleProvider != nullptr) ? S_OK : E_OUTOFMEMORY;
+//}
+
+//TODO: fix
+//HRESULT FFmpegInteropMSS::CreateVideoStreamDescriptor(bool forceVideoDecode)
+//{
+//	VideoEncodingProperties^ videoProperties;
+//
+//	if (avVideoCodecCtx->codec_id == AV_CODEC_ID_H264 && !forceVideoDecode)
+//	{
+//		videoProperties = VideoEncodingProperties::CreateH264();
+//		videoProperties->ProfileId = avVideoCodecCtx->profile;
+//		videoProperties->Height = avVideoCodecCtx->height;
+//		videoProperties->Width = avVideoCodecCtx->width;
+//
+//		// Check for H264 bitstream flavor. H.264 AVC extradata starts with 1 while non AVC one starts with 0
+//		if (avVideoCodecCtx->extradata != nullptr && avVideoCodecCtx->extradata_size > 0 && avVideoCodecCtx->extradata[0] == 1)
+//		{
+//			videoSampleProvider = ref new H264AVCSampleProvider(m_pReader, avFormatCtx, avVideoCodecCtx);
+//		}
+//		else
+//		{
+//			videoSampleProvider = ref new H264SampleProvider(m_pReader, avFormatCtx, avVideoCodecCtx);
+//		}
+//	}
+//	else
+//	{
+//		videoProperties = VideoEncodingProperties::CreateUncompressed(MediaEncodingSubtypes::Nv12, avVideoCodecCtx->width, avVideoCodecCtx->height);
+//		videoSampleProvider = ref new UncompressedVideoSampleProvider(m_pReader, avFormatCtx, avVideoCodecCtx);
+//
+//		if (avVideoCodecCtx->sample_aspect_ratio.num > 0 && avVideoCodecCtx->sample_aspect_ratio.den != 0)
+//		{
+//			videoProperties->PixelAspectRatio->Numerator = avVideoCodecCtx->sample_aspect_ratio.num;
+//			videoProperties->PixelAspectRatio->Denominator = avVideoCodecCtx->sample_aspect_ratio.den;
+//		}
+//
+//		videoProperties->Properties->Insert(MF_MT_INTERLACE_MODE, (uint32)_MFVideoInterlaceMode::MFVideoInterlace_MixedInterlaceOrProgressive);
+//	}
+//	if (rotateVideo)
+//	{
+//		Platform::Guid MF_MT_VIDEO_ROTATION(0xC380465D, 0x2271, 0x428C, 0x9B, 0x83, 0xEC, 0xEA, 0x3B, 0x4A, 0x85, 0xC1);
+//		videoProperties->Properties->Insert(MF_MT_VIDEO_ROTATION, (uint32)rotationAngle);
+//	}
+//	// Detect the correct framerate
+//	if (avVideoCodecCtx->framerate.num != 0 || avVideoCodecCtx->framerate.den != 1)
+//	{
+//		videoProperties->FrameRate->Numerator = avVideoCodecCtx->framerate.num;
+//		videoProperties->FrameRate->Denominator = avVideoCodecCtx->framerate.den;
+//	}
+//	else if (avFormatCtx->streams[videoStreamIndex]->avg_frame_rate.num != 0 || avFormatCtx->streams[videoStreamIndex]->avg_frame_rate.den != 0)
+//	{
+//		videoProperties->FrameRate->Numerator = avFormatCtx->streams[videoStreamIndex]->avg_frame_rate.num;
+//		videoProperties->FrameRate->Denominator = avFormatCtx->streams[videoStreamIndex]->avg_frame_rate.den;
+//	}
+//
+//	videoProperties->Bitrate = (unsigned int)avVideoCodecCtx->bit_rate;
+//	videoStreamDescriptor = ref new VideoStreamDescriptor(videoProperties);
+//
+//	return (videoStreamDescriptor != nullptr && videoSampleProvider != nullptr) ? S_OK : E_OUTOFMEMORY;
+//}
+
+
+// TODO:fix
+//HRESULT FFmpegInteropMSS::ParseOptions(PropertySet^ ffmpegOptions)
+//{
+//	HRESULT hr = S_OK;
+//
+//	// Convert FFmpeg options given in PropertySet to AVDictionary. List of options can be found in https://www.ffmpeg.org/ffmpeg-protocols.html
+//	if (ffmpegOptions != nullptr)
+//	{
+//		auto options = ffmpegOptions->First();
+//
+//		while (options->HasCurrent)
+//		{
+//			String^ key = options->Current->Key;
+//			std::wstring keyW(key->Begin());
+//			std::string keyA(keyW.begin(), keyW.end());
+//			const char* keyChar = keyA.c_str();
+//
+//			// Convert value from Object^ to const char*. avformat_open_input will internally convert value from const char* to the correct type
+//			String^ value = options->Current->Value->ToString();
+//			std::wstring valueW(value->Begin());
+//			std::string valueA(valueW.begin(), valueW.end());
+//			const char* valueChar = valueA.c_str();
+//
+//			// Add key and value pair entry
+//			if (av_dict_set(&avDict, keyChar, valueChar, 0) < 0)
+//			{
+//				hr = E_INVALIDARG;
+//				break;
+//			}
+//
+//			options->MoveNext();
+//		}
+//	}
+//
+//	return hr;
+//}
+
+//void FFmpegInteropMSS::OnStarting(MediaStreamSource ^sender, MediaStreamSourceStartingEventArgs ^args)
+void FFmpegInteropMSS::Starting(System::TimeSpan startPosition)
+{
+	//MediaStreamSourceStartingRequest^ request = args->Request;
+	DebugMessage(L"OnStarting\n");
+
+	// Perform seek operation when MediaStreamSource received seek event from MediaElement
+	if (startPosition.Ticks <= mediaDuration.Ticks)
+	{
+		// Select the first valid stream either from video or audio
+		int streamIndex = videoStreamIndex >= 0 ? videoStreamIndex : audioStreamIndex >= 0 ? audioStreamIndex : -1;
+
+		if (streamIndex >= 0)
+		{
+			// Convert TimeSpan unit to AV_TIME_BASE
+			int64_t seekTarget = static_cast<int64_t>(startPosition.Ticks / (av_q2d(avFormatCtx->streams[streamIndex]->time_base) * 10000000));
+
+			if (av_seek_frame(avFormatCtx, streamIndex, seekTarget, AVSEEK_FLAG_BACKWARD) < 0)
+			{
+				DebugMessage(L" - ### Error while seeking\n");
+			}
+			else
+			{
+				// Add deferral
+
+				// Flush the AudioSampleProvider
+				if (audioSampleProvider != nullptr)
+				{
+					audioSampleProvider->Flush();
+					avcodec_flush_buffers(avAudioCodecCtx);
+				}
+
+				// Flush the VideoSampleProvider
+				if (videoSampleProvider != nullptr)
+				{
+					videoSampleProvider->Flush();
+					avcodec_flush_buffers(avVideoCodecCtx);
+				}
+			}
+		}
+
+		// TODO: fix
+		//request->SetActualStartPosition(request->StartPosition->Value);
+	}
+}
+
+
+//void FFmpegInteropMSS::OnSampleRequested(Windows::Media::Core::MediaStreamSource ^sender, MediaStreamSourceSampleRequestedEventArgs ^args)
+MyMediaStreamSample^ FFmpegInteropMSS::SampleRequested(bool audioStreamRequested)
+{
+	DebugMessage(L"OnSampleRequested\n");
+	//mutexGuard.lock();
+	msclr::lock lockGuard(this);
+	//if (mss != nullptr)
+	//{
+		//if (args->Request->StreamDescriptor == audioStreamDescriptor && audioSampleProvider != nullptr)
+		if (audioStreamRequested && audioSampleProvider != nullptr)
+		{
+			return audioSampleProvider->GetNextSample();
+		}
+		//else if (args->Request->StreamDescriptor == videoStreamDescriptor && videoSampleProvider != nullptr)
+		else if (!audioStreamRequested && videoSampleProvider != nullptr)
+		{
+			return videoSampleProvider->GetNextSample();
+		}
+		else
+		{
+			return nullptr;
+		}
+	//}
+	//mutexGuard.unlock();
+}
+
+// Static function to read file stream and pass data to FFmpeg. Credit to Philipp Sch http://www.codeproject.com/Tips/489450/Creating-Custom-FFmpeg-IO-Context
+static int FileStreamRead(void* ptr, uint8_t* buf, int bufSize)
+{
+	IStream* pStream = reinterpret_cast<IStream*>(ptr);
+	ULONG bytesRead = 0;
+	HRESULT hr = pStream->Read(buf, bufSize, &bytesRead);
+
+	if (FAILED(hr))
+	{
+		return -1;
+	}
+
+	// If we succeed but don't have any bytes, assume end of file
+	if (bytesRead == 0)
+	{
+		return AVERROR_EOF;  // Let FFmpeg know that we have reached eof
+	}
+
+	return bytesRead;
+}
+
+// Static function to seek in file stream. Credit to Philipp Sch http://www.codeproject.com/Tips/489450/Creating-Custom-FFmpeg-IO-Context
+static int64_t FileStreamSeek(void* ptr, int64_t pos, int whence)
+{
+	IStream* pStream = reinterpret_cast<IStream*>(ptr);
+	LARGE_INTEGER in;
+	in.QuadPart = pos;
+	ULARGE_INTEGER out = { 0 };
+
+	if (FAILED(pStream->Seek(in, whence, &out)))
+	{
+		return -1;
+	}
+
+	return out.QuadPart; // Return the new position:
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropMSS.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropMSS.h
new file mode 100644
index 0000000..208bc89
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegInteropMSS.h
@@ -0,0 +1,157 @@
+﻿//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#pragma once
+
+#include <queue>
+//#include <mutex>
+#include <atlbase.h>
+#include <objidl.h>
+#include <mfapi.h>
+
+#include "FFmpegReader.h"
+#include "MediaSampleProvider.h"
+//#include "MediaThumbnailData.h"
+
+//using namespace Platform;
+//using namespace Windows::Foundation;
+//using namespace Windows::Foundation::Collections;
+//using namespace Windows::Media::Core;
+using namespace System;
+using namespace System::IO;
+
+extern "C"
+{
+#include <libavformat/avformat.h>
+}
+
+namespace FFmpegInterop
+{
+	public ref class FFmpegInteropMSS sealed
+	{
+	public:
+		//static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromStream(IStream* stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss);
+		//static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromStream(IStream* stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions);
+		//static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromStream(CComPtr<IStream> stream, bool forceAudioDecode, bool forceVideoDecode);
+		static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromStream(System::Runtime::InteropServices::ComTypes::IStream ^stream, bool forceAudioDecode, bool forceVideoDecode);
+		//static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromStream(System::IO::Stream^ stream, bool forceAudioDecode, bool forceVideoDecode);
+
+		//static HRESULT __stdcall CreateFFmpegInteropMSSFromStream2(IStream* stream, bool forceAudioDecode, bool forceVideoDecode);
+
+
+		//static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromUri(String^ uri, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions);
+		static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromUri(String^ uri, bool forceAudioDecode, bool forceVideoDecode);
+		//MediaThumbnailData^ ExtractThumbnail();
+
+		void Starting(System::TimeSpan startPosition);
+		MyMediaStreamSample^ SampleRequested(bool audioStreamRequested);
+
+		// Contructor
+		//MediaStreamSource^ GetMediaStreamSource();
+		virtual ~FFmpegInteropMSS();
+
+		// Properties
+		//property AudioStreamDescriptor^ AudioDescriptor
+		//{
+		//	AudioStreamDescriptor^ get()
+		//	{
+		//		return audioStreamDescriptor;
+		//	};
+		//};
+		//property VideoStreamDescriptor^ VideoDescriptor
+		//{
+		//	VideoStreamDescriptor^ get()
+		//	{
+		//		return videoStreamDescriptor;
+		//	};
+		//};
+
+		property TimeSpan Duration
+		{
+			TimeSpan get()
+			{
+				return mediaDuration;
+			};
+		};
+		property String^ VideoCodecName
+		{
+			String^ get()
+			{
+				return videoCodecName;
+			};
+		};
+		property String^ AudioCodecName
+		{
+			String^ get()
+			{
+				return audioCodecName;
+			};
+		};
+
+	//internal:
+	//	int ReadPacket();
+
+	private:
+		FFmpegInteropMSS();
+
+		//HRESULT CreateMediaStreamSource(IStream* stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss);
+		HRESULT CreateMediaStreamSource(IStream* stream, bool forceAudioDecode, bool forceVideoDecode);
+		//HRESULT CreateMediaStreamSource(String^ uri, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions);
+		HRESULT CreateMediaStreamSource(String^ uri, bool forceAudioDecode, bool forceVideoDecode);
+
+		HRESULT InitFFmpegContext(bool forceAudioDecode, bool forceVideoDecode);
+		//HRESULT CreateAudioStreamDescriptor(bool forceAudioDecode);
+		//HRESULT CreateVideoStreamDescriptor(bool forceVideoDecode);
+		HRESULT ConvertCodecName(const char* codecName, String^ %outputCodecName);
+		//HRESULT ParseOptions(PropertySet^ ffmpegOptions);
+		//void OnStarting(MediaStreamSource ^sender, MediaStreamSourceStartingEventArgs ^args);
+		//void OnSampleRequested(MediaStreamSource ^sender, MediaStreamSourceSampleRequestedEventArgs ^args);
+
+		//MediaStreamSource^ mss;
+		//EventRegistrationToken startingRequestedToken;
+		//EventRegistrationToken sampleRequestedToken;
+
+		internal:
+		AVDictionary* avDict;
+		AVIOContext* avIOCtx;
+		AVFormatContext* avFormatCtx;
+		AVCodecContext* avAudioCodecCtx;
+		AVCodecContext* avVideoCodecCtx;
+
+		private:
+		//AudioStreamDescriptor^ audioStreamDescriptor;
+		//VideoStreamDescriptor^ videoStreamDescriptor;
+		int audioStreamIndex;
+		int videoStreamIndex;
+		int thumbnailStreamIndex;
+		
+		bool rotateVideo;
+		int rotationAngle;
+		//std::recursive_mutex mutexGuard;
+		
+		MediaSampleProvider^ audioSampleProvider;
+		MediaSampleProvider^ videoSampleProvider;
+
+		String^ videoCodecName;
+		String^ audioCodecName;
+		TimeSpan mediaDuration;
+		IStream* fileStreamData;
+		unsigned char* fileStreamBuffer;
+		FFmpegReader^ m_pReader;
+	};
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegReader.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegReader.cpp
new file mode 100644
index 0000000..dc7fe0a
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegReader.cpp
@@ -0,0 +1,88 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#include "stdafx.h"
+#include "FFmpegReader.h"
+
+using namespace FFmpegInterop;
+
+FFmpegReader::FFmpegReader(AVFormatContext* avFormatCtx)
+	: m_pAvFormatCtx(avFormatCtx)
+	, m_audioStreamIndex(AVERROR_STREAM_NOT_FOUND)
+	, m_videoStreamIndex(AVERROR_STREAM_NOT_FOUND)
+{
+}
+
+FFmpegReader::~FFmpegReader()
+{
+}
+
+// Read the next packet from the stream and push it into the appropriate
+// sample provider
+int FFmpegReader::ReadPacket()
+{
+	int ret;
+	AVPacket avPacket;
+	av_init_packet(&avPacket);
+	avPacket.data = NULL;
+	avPacket.size = 0;
+
+	ret = av_read_frame(m_pAvFormatCtx, &avPacket);
+	if (ret < 0)
+	{
+		return ret;
+	}
+
+	// Push the packet to the appropriate
+	if (avPacket.stream_index == m_audioStreamIndex && m_audioSampleProvider != nullptr)
+	{
+		m_audioSampleProvider->QueuePacket(avPacket);
+	}
+	else if (avPacket.stream_index == m_videoStreamIndex && m_videoSampleProvider != nullptr)
+	{
+		m_videoSampleProvider->QueuePacket(avPacket);
+	}
+	else
+	{
+		DebugMessage(L"Ignoring unused stream\n");
+		av_packet_unref(&avPacket);
+	}
+
+	return ret;
+}
+
+void FFmpegReader::SetAudioStream(int audioStreamIndex, MediaSampleProvider^ audioSampleProvider)
+{
+	m_audioStreamIndex = audioStreamIndex;
+	m_audioSampleProvider = audioSampleProvider;
+	if (audioSampleProvider != nullptr)
+	{
+		audioSampleProvider->SetCurrentStreamIndex(m_audioStreamIndex);
+	}
+}
+
+void FFmpegReader::SetVideoStream(int videoStreamIndex, MediaSampleProvider^ videoSampleProvider)
+{
+	m_videoStreamIndex = videoStreamIndex;
+	m_videoSampleProvider = videoSampleProvider;
+	if (videoSampleProvider != nullptr)
+	{
+		videoSampleProvider->SetCurrentStreamIndex(m_videoStreamIndex);
+	}
+}
+
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegReader.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegReader.h
new file mode 100644
index 0000000..668bef9
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/FFmpegReader.h
@@ -0,0 +1,49 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#pragma once
+
+#include "MediaSampleProvider.h"
+
+//extern "C"
+//{
+//#include <libavformat/avformat.h>
+//}
+
+namespace FFmpegInterop
+{
+
+	ref class FFmpegReader
+	{
+	public:
+		virtual ~FFmpegReader();
+		int ReadPacket();
+		void SetAudioStream(int audioStreamIndex, MediaSampleProvider^ audioSampleProvider);
+		void SetVideoStream(int videoStreamIndex, MediaSampleProvider^ videoSampleProvider);
+
+	internal:
+		FFmpegReader(AVFormatContext* avFormatCtx);
+
+	private:
+		AVFormatContext* m_pAvFormatCtx;
+		MediaSampleProvider^ m_audioSampleProvider;
+		int m_audioStreamIndex;
+		MediaSampleProvider^ m_videoSampleProvider;
+		int m_videoStreamIndex;
+	};
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/H264AVCSampleProvider.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/H264AVCSampleProvider.cpp
new file mode 100644
index 0000000..d1e99b0
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/H264AVCSampleProvider.cpp
@@ -0,0 +1,169 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#include "pch.h"
+#include "H264AVCSampleProvider.h"
+
+using namespace FFmpegInterop;
+
+H264AVCSampleProvider::H264AVCSampleProvider(
+	FFmpegReader^ reader,
+	AVFormatContext* avFormatCtx,
+	AVCodecContext* avCodecCtx)
+	: MediaSampleProvider(reader, avFormatCtx, avCodecCtx)
+{
+}
+
+H264AVCSampleProvider::~H264AVCSampleProvider()
+{
+}
+
+HRESULT H264AVCSampleProvider::WriteAVPacketToStream(DataWriter^ dataWriter, AVPacket* avPacket)
+{
+	HRESULT hr = S_OK;
+	// On a KeyFrame, write the SPS and PPS
+	if (avPacket->flags & AV_PKT_FLAG_KEY)
+	{
+		hr = GetSPSAndPPSBuffer(dataWriter);
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Convert the packet to NAL format
+		hr = WriteNALPacket(dataWriter, avPacket);
+	}
+
+	// We have a complete frame
+	return hr;
+}
+
+HRESULT H264AVCSampleProvider::GetSPSAndPPSBuffer(DataWriter^ dataWriter)
+{
+	HRESULT hr = S_OK;
+	int spsLength = 0;
+	int ppsLength = 0;
+
+	// Get the position of the SPS
+	if (m_pAvCodecCtx->extradata == nullptr && m_pAvCodecCtx->extradata_size < 8)
+	{
+		// The data isn't present
+		hr = E_FAIL;
+	}
+	if (SUCCEEDED(hr))
+	{
+		byte* spsPos = m_pAvCodecCtx->extradata + 8;
+		spsLength = spsPos[-1];
+
+		if (m_pAvCodecCtx->extradata_size < (8 + spsLength))
+		{
+			// We don't have a complete SPS
+			hr = E_FAIL;
+		}
+		else
+		{
+			auto vSPS = ref new Platform::Array<uint8_t>(spsPos, spsLength);
+
+			// Write the NAL unit for the SPS
+			dataWriter->WriteByte(0);
+			dataWriter->WriteByte(0);
+			dataWriter->WriteByte(0);
+			dataWriter->WriteByte(1);
+
+			// Write the SPS
+			dataWriter->WriteBytes(vSPS);
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		if (m_pAvCodecCtx->extradata_size < (8 + spsLength + 3))
+		{
+			hr = E_FAIL;
+		}
+
+		if (SUCCEEDED(hr))
+		{
+			byte* ppsPos = m_pAvCodecCtx->extradata + 8 + spsLength + 3;
+			ppsLength = ppsPos[-1];
+
+			if (m_pAvCodecCtx->extradata_size < (8 + spsLength + 3 + ppsLength))
+			{
+				hr = E_FAIL;
+			}
+			else
+			{
+				auto vPPS = ref new Platform::Array<uint8_t>(ppsPos, ppsLength);
+
+				// Write the NAL unit for the PPS
+				dataWriter->WriteByte(0);
+				dataWriter->WriteByte(0);
+				dataWriter->WriteByte(0);
+				dataWriter->WriteByte(1);
+
+				// Write the PPS
+				dataWriter->WriteBytes(vPPS);
+			}
+		}
+	}
+
+	return hr;
+}
+
+// Write out an H.264 packet converting stream offsets to start-codes
+HRESULT H264AVCSampleProvider::WriteNALPacket(DataWriter^ dataWriter, AVPacket* avPacket)
+{
+	HRESULT hr = S_OK;
+	uint32 index = 0;
+	uint32 size = 0;
+	uint32 packetSize = (uint32)avPacket->size;
+
+	do
+	{
+		// Make sure we have enough data
+		if (packetSize < (index + 4))
+		{
+			hr = E_FAIL;
+			break;
+		}
+
+		// Grab the size of the blob
+		size = (avPacket->data[index] << 24) + (avPacket->data[index + 1] << 16) + (avPacket->data[index + 2] << 8) + avPacket->data[index + 3];
+
+		// Write the NAL unit to the stream
+		dataWriter->WriteByte(0);
+		dataWriter->WriteByte(0);
+		dataWriter->WriteByte(0);
+		dataWriter->WriteByte(1);
+		index += 4;
+
+		// Stop if index and size goes beyond packet size or overflow
+		if (packetSize < (index + size) || (UINT32_MAX - index) < size)
+		{
+			hr = E_FAIL;
+			break;
+		}
+
+		// Write the rest of the packet to the stream
+		auto vBuffer = ref new Platform::Array<uint8_t>(&(avPacket->data[index]), size);
+		dataWriter->WriteBytes(vBuffer);
+		index += size;
+	} while (index < packetSize);
+
+	return hr;
+}
+
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/H264AVCSampleProvider.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/H264AVCSampleProvider.h
new file mode 100644
index 0000000..a13e775
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/H264AVCSampleProvider.h
@@ -0,0 +1,41 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#pragma once
+#include "MediaSampleProvider.h"
+
+namespace FFmpegInterop
+{
+	ref class H264AVCSampleProvider :
+		public MediaSampleProvider
+	{
+	public:
+		virtual ~H264AVCSampleProvider();
+
+	private:
+		HRESULT WriteNALPacket(DataWriter^ dataWriter, AVPacket* avPacket);
+		HRESULT GetSPSAndPPSBuffer(DataWriter^ dataWriter);
+
+	internal:
+		H264AVCSampleProvider(
+			FFmpegReader^ reader,
+			AVFormatContext* avFormatCtx,
+			AVCodecContext* avCodecCtx);
+		virtual HRESULT WriteAVPacketToStream(DataWriter^ writer, AVPacket* avPacket) override;
+	};
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/H264SampleProvider.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/H264SampleProvider.cpp
new file mode 100644
index 0000000..0136701
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/H264SampleProvider.cpp
@@ -0,0 +1,72 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#include "pch.h"
+#include "H264SampleProvider.h"
+
+using namespace FFmpegInterop;
+
+H264SampleProvider::H264SampleProvider(
+	FFmpegReader^ reader,
+	AVFormatContext* avFormatCtx,
+	AVCodecContext* avCodecCtx)
+	: MediaSampleProvider(reader, avFormatCtx, avCodecCtx)
+{
+}
+
+H264SampleProvider::~H264SampleProvider()
+{
+}
+
+HRESULT H264SampleProvider::WriteAVPacketToStream(DataWriter^ dataWriter, AVPacket* avPacket)
+{
+	HRESULT hr = S_OK;
+	// On a KeyFrame, write the SPS and PPS
+	if (avPacket->flags & AV_PKT_FLAG_KEY)
+	{
+		hr = GetSPSAndPPSBuffer(dataWriter);
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Call base class method that simply write the packet to stream as is
+		hr = MediaSampleProvider::WriteAVPacketToStream(dataWriter, avPacket);
+	}
+
+	// We have a complete frame
+	return hr;
+}
+
+HRESULT H264SampleProvider::GetSPSAndPPSBuffer(DataWriter^ dataWriter)
+{
+	HRESULT hr = S_OK;
+
+	if (m_pAvCodecCtx->extradata == nullptr && m_pAvCodecCtx->extradata_size < 8)
+	{
+		// The data isn't present
+		hr = E_FAIL;
+	}
+	else
+	{
+		// Write both SPS and PPS sequence as is from extradata
+		auto vSPSPPS = ref new Platform::Array<uint8_t>(m_pAvCodecCtx->extradata, m_pAvCodecCtx->extradata_size);
+		dataWriter->WriteBytes(vSPSPPS);
+	}
+
+	return hr;
+}
\ No newline at end of file
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/H264SampleProvider.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/H264SampleProvider.h
new file mode 100644
index 0000000..82600c1
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/H264SampleProvider.h
@@ -0,0 +1,40 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#pragma once
+#include "MediaSampleProvider.h"
+
+namespace FFmpegInterop
+{
+	ref class H264SampleProvider :
+		public MediaSampleProvider
+	{
+	public:
+		virtual ~H264SampleProvider();
+
+	private:
+		HRESULT GetSPSAndPPSBuffer(DataWriter^ dataWriter);
+
+	internal:
+		H264SampleProvider(
+			FFmpegReader^ reader,
+			AVFormatContext* avFormatCtx,
+			AVCodecContext* avCodecCtx);
+		virtual HRESULT WriteAVPacketToStream(DataWriter^ writer, AVPacket* avPacket) override;
+	};
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/ILogProvider.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/ILogProvider.h
new file mode 100644
index 0000000..fb1ad51
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/ILogProvider.h
@@ -0,0 +1,43 @@
+//*****************************************************************************
+//
+//	Copyright 2017 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#pragma once
+
+using namespace Platform;
+
+namespace FFmpegInterop
+{
+	// Level values from ffmpeg: libavutil/log.h
+	public enum class LogLevel
+	{
+		Panic = 0,
+		Fatal = 8,
+		Error = 16,
+		Warning = 24,
+		Info = 32,
+		Verbose = 40,
+		Debug = 48,
+		Trace = 56
+	};
+
+	public interface class ILogProvider
+	{
+		void Log(LogLevel level, String^ message);
+	};
+}
+
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/MediaSampleProvider.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/MediaSampleProvider.cpp
new file mode 100644
index 0000000..c39ed8e
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/MediaSampleProvider.cpp
@@ -0,0 +1,217 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#include "stdafx.h"
+#include "MediaSampleProvider.h"
+#include "FFmpegInteropMSS.h"
+#include "FFmpegReader.h"
+
+using namespace FFmpegInterop;
+
+MediaSampleProvider::MediaSampleProvider(
+	FFmpegReader^ reader,
+	AVFormatContext* avFormatCtx,
+	AVCodecContext* avCodecCtx)
+	: m_pReader(reader)
+	, m_pAvFormatCtx(avFormatCtx)
+	, m_pAvCodecCtx(avCodecCtx)
+	, m_streamIndex(AVERROR_STREAM_NOT_FOUND)
+{
+	DebugMessage(L"MediaSampleProvider\n");
+	m_startOffset = -1;
+}
+
+HRESULT MediaSampleProvider::AllocateResources()
+{
+	DebugMessage(L"AllocateResources\n");
+	m_startOffset = -1;
+	return S_OK;
+}
+
+MediaSampleProvider::MediaSampleProvider()
+{
+	m_packetQueue = new std::vector<AVPacket>;
+}
+
+MediaSampleProvider::~MediaSampleProvider()
+{
+	delete m_packetQueue;
+	DebugMessage(L"~MediaSampleProvider\n");
+}
+
+void MediaSampleProvider::SetCurrentStreamIndex(int streamIndex)
+{
+	DebugMessage(L"SetCurrentStreamIndex\n");
+	if (m_pAvCodecCtx != nullptr && m_pAvFormatCtx->nb_streams > (unsigned int)streamIndex)
+	{
+		m_streamIndex = streamIndex;
+	}
+	else
+	{
+		m_streamIndex = AVERROR_STREAM_NOT_FOUND;
+	}
+}
+
+// TODO: return sample the other way
+MyMediaStreamSample^ MediaSampleProvider::GetNextSample()
+{
+	DebugMessage(L"GetNextSample\n");
+
+	HRESULT hr = S_OK;
+
+	MyMediaStreamSample^ sample;
+	MemoryStream mem;
+	BinaryWriter dataWriter(%mem);
+
+	LONGLONG pts = 0;
+	LONGLONG dur = 0;
+
+	hr = GetNextPacket(%dataWriter, pts, dur);
+
+	if (hr == S_OK)
+	{
+		dataWriter.Flush();
+		//auto buf = mem.GetBuffer();
+
+		sample = MyMediaStreamSample::CreateFromStream(%mem, pts, dur);
+		//sample->Duration = { dur };
+	}
+
+	return sample;
+}
+
+HRESULT MediaSampleProvider::WriteAVPacketToStream(BinaryWriter^ dataWriter, AVPacket* avPacket)
+{
+	// This is the simplest form of transfer. Copy the packet directly to the stream
+	// This works for most compressed formats
+	// TODO: looks like impossible without copying??
+	// TODO: fix this to use array directly instead of BinaryWriter and stream, so that copying occurs only once
+	auto copy = gcnew array<uint8_t>(avPacket->size);
+	System::Runtime::InteropServices::Marshal::Copy(IntPtr((void*)avPacket->data), copy, 0, avPacket->size);
+	//auto aBuffer = ref new Platform::Array<uint8_t>(avPacket->data, avPacket->size);
+	dataWriter->Write(copy);
+	return S_OK;
+}
+
+HRESULT MediaSampleProvider::DecodeAVPacket(BinaryWriter^ dataWriter, AVPacket *avPacket, int64_t &framePts, int64_t &frameDuration)
+{
+	// For the simple case of compressed samples, each packet is a sample
+	if (avPacket != nullptr && avPacket->pts != AV_NOPTS_VALUE)
+	{
+		framePts = avPacket->pts;
+		frameDuration = avPacket->duration;
+	}
+	return S_OK;
+}
+
+void MediaSampleProvider::QueuePacket(AVPacket packet)
+{
+	DebugMessage(L" - QueuePacket\n");
+
+	m_packetQueue->push_back(packet);
+}
+
+AVPacket MediaSampleProvider::PopPacket()
+{
+	DebugMessage(L" - PopPacket\n");
+
+	AVPacket avPacket;
+	av_init_packet(&avPacket);
+	avPacket.data = NULL;
+	avPacket.size = 0;
+
+	if (!m_packetQueue->empty())
+	{
+		avPacket = m_packetQueue->front();
+		m_packetQueue->erase(m_packetQueue->begin());
+	}
+
+	return avPacket;
+}
+
+HRESULT FFmpegInterop::MediaSampleProvider::GetNextPacket(BinaryWriter^ writer, LONGLONG & pts, LONGLONG & dur)
+{
+	HRESULT hr = S_OK;
+
+	AVPacket avPacket;
+	av_init_packet(&avPacket);
+	avPacket.data = NULL;
+	avPacket.size = 0;
+
+	bool frameComplete = false;
+	bool decodeSuccess = true;
+	int64_t framePts = 0, frameDuration = 0;
+
+	while (SUCCEEDED(hr) && !frameComplete)
+	{
+		// Continue reading until there is an appropriate packet in the stream
+		while (m_packetQueue->empty())
+		{
+			if (m_pReader->ReadPacket() < 0)
+			{
+				DebugMessage(L"GetNextSample reaching EOF\n");
+				hr = E_FAIL;
+				break;
+			}
+		}
+
+		if (!m_packetQueue->empty())
+		{
+			// Pick the packets from the queue one at a time
+			avPacket = PopPacket();
+			framePts = avPacket.pts;
+			frameDuration = avPacket.duration;
+
+			// Decode the packet if necessary, it will update the presentation time if necessary
+			hr = DecodeAVPacket(writer, &avPacket, framePts, frameDuration);
+			frameComplete = (hr == S_OK);
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Write the packet out
+		hr = WriteAVPacketToStream(writer, &avPacket);
+
+		if (m_startOffset == -1)
+		{
+			//if we havent set m_startOffset already
+			DebugMessage(L"Saving m_startOffset\n");
+
+			//in some real-time streams framePts is less than 0 so we need to make sure m_startOffset is never negative
+			m_startOffset = framePts < 0 ? 0 : framePts;
+		}
+
+		pts = LONGLONG(av_q2d(m_pAvFormatCtx->streams[m_streamIndex]->time_base) * 10000000 * (framePts - m_startOffset));
+
+		dur = LONGLONG(av_q2d(m_pAvFormatCtx->streams[m_streamIndex]->time_base) * 10000000 * frameDuration);
+	}
+
+	av_packet_unref(&avPacket);
+
+	return hr;
+}
+
+void MediaSampleProvider::Flush()
+{
+	DebugMessage(L"Flush\n");
+	while (!m_packetQueue->empty())
+	{
+		av_packet_unref(&PopPacket());
+	}
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/MediaSampleProvider.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/MediaSampleProvider.h
new file mode 100644
index 0000000..7c52bd6
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/MediaSampleProvider.h
@@ -0,0 +1,84 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#pragma once
+#include <queue>
+//#include <memory>
+//#include <cliext/vector>
+//#include <winnt.h>
+#include <mfapi.h>
+#include "MyMediaStreamSample.h"
+
+extern "C"
+{
+#include <libavformat/avformat.h>
+}
+
+//using namespace Windows::Storage::Streams;
+//using namespace Windows::Media::Core;
+using namespace System;
+//using namespace cliext;
+
+
+namespace FFmpegInterop
+{
+	ref class FFmpegInteropMSS;
+	ref class FFmpegReader;
+
+	ref class MediaSampleProvider
+	{
+	public:
+		MediaSampleProvider();
+		virtual ~MediaSampleProvider();
+		//virtual MediaStreamSample^ GetNextSample();
+		virtual MyMediaStreamSample^ GetNextSample();
+		virtual void Flush();
+		virtual void SetCurrentStreamIndex(int streamIndex);
+
+	internal:
+		void QueuePacket(AVPacket packet);
+		AVPacket PopPacket();
+
+	private:
+		std::vector<AVPacket> *m_packetQueue;
+		//cliext::vector<AVPacket^> m_packetQueue;
+		int m_streamIndex;
+		System::Int64 m_startOffset = 0;
+
+	internal:
+		// The FFmpeg context. Because they are complex types
+		// we declare them as internal so they don't get exposed
+		// externally
+		FFmpegReader^ m_pReader;
+		AVFormatContext* m_pAvFormatCtx;
+		AVCodecContext* m_pAvCodecCtx;
+
+	internal:
+		MediaSampleProvider(
+			FFmpegReader^ reader,
+			AVFormatContext* avFormatCtx,
+			AVCodecContext* avCodecCtx);
+		virtual HRESULT AllocateResources();
+		//virtual HRESULT WriteAVPacketToStream(DataWriter^ writer, AVPacket* avPacket);
+		//virtual HRESULT DecodeAVPacket(DataWriter^ dataWriter, AVPacket* avPacket, int64_t& framePts, int64_t& frameDuration);
+		//virtual HRESULT GetNextPacket(DataWriter^ writer, LONGLONG& pts, LONGLONG& dur);
+		virtual HRESULT WriteAVPacketToStream(BinaryWriter^ writer, AVPacket* avPacket);
+		virtual HRESULT DecodeAVPacket(BinaryWriter^ writer, AVPacket* avPacket, int64_t& framePts, int64_t& frameDuration);
+		virtual HRESULT GetNextPacket(BinaryWriter^ writer, LONGLONG& pts, LONGLONG& dur);
+	};
+}
\ No newline at end of file
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/MediaThumbnailData.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/MediaThumbnailData.h
new file mode 100644
index 0000000..9cf2d3d
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/MediaThumbnailData.h
@@ -0,0 +1,58 @@
+//*****************************************************************************
+//
+//	Copyright 2017 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#pragma once
+using namespace Platform;
+using namespace Windows::Storage::Streams;
+
+namespace FFmpegInterop
+{
+	public ref class MediaThumbnailData sealed
+	{
+		IBuffer^ _buffer;
+		String^ _extension;
+
+	public:
+
+		property IBuffer^ Buffer
+		{
+			IBuffer^ get()
+			{
+				return _buffer;
+			}
+		}
+		property String^ Extension
+		{
+			String^ get()
+			{
+				return _extension;
+			}
+		}
+
+		MediaThumbnailData(IBuffer^ buffer, String^ extension)
+		{
+			this->_buffer = buffer;
+			this->_extension = extension;
+		}
+	private: ~MediaThumbnailData()
+		{
+			delete _buffer;
+			delete _extension;
+		}
+	};
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/MyMediaStreamSample.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/MyMediaStreamSample.cpp
new file mode 100644
index 0000000..00202aa
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/MyMediaStreamSample.cpp
@@ -0,0 +1,18 @@
+#include "stdafx.h"
+#include "MyMediaStreamSample.h"
+
+
+MyMediaStreamSample::MyMediaStreamSample()
+{
+}
+
+
+MyMediaStreamSample::~MyMediaStreamSample()
+{
+}
+
+MyMediaStreamSample ^ MyMediaStreamSample::CreateFromStream(Stream^ stream, LONGLONG pts, LONGLONG dur)
+{
+	throw gcnew System::NotImplementedException();
+	// TODO: insert return statement here
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/MyMediaStreamSample.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/MyMediaStreamSample.h
new file mode 100644
index 0000000..5c225cc
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/MyMediaStreamSample.h
@@ -0,0 +1,15 @@
+#pragma once
+
+#include <mfapi.h>
+
+using namespace System::IO;
+
+public ref class MyMediaStreamSample
+{
+protected:
+	MyMediaStreamSample();
+public:
+	virtual ~MyMediaStreamSample();
+	static MyMediaStreamSample^ CreateFromStream(Stream^ stream, LONGLONG pts, LONGLONG dur);
+};
+
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/ReadMe.txt b/FFmpegInterop/CLR/FFmpegInterop.CLR/ReadMe.txt
new file mode 100644
index 0000000..2800382
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/ReadMe.txt
@@ -0,0 +1,38 @@
+========================================================================
+    DYNAMIC LINK LIBRARY : FFmpegInterop.CLR Project Overview
+========================================================================
+
+AppWizard has created this FFmpegInterop.CLR DLL for you.  
+
+This file contains a summary of what you will find in each of the files that
+make up your FFmpegInterop.CLR application.
+
+FFmpegInterop.CLR.vcxproj
+    This is the main project file for VC++ projects generated using an Application Wizard. 
+    It contains information about the version of Visual C++ that generated the file, and 
+    information about the platforms, configurations, and project features selected with the
+    Application Wizard.
+
+FFmpegInterop.CLR.vcxproj.filters
+    This is the filters file for VC++ projects generated using an Application Wizard. 
+    It contains information about the association between the files in your project 
+    and the filters. This association is used in the IDE to show grouping of files with
+    similar extensions under a specific node (for e.g. ".cpp" files are associated with the
+    "Source Files" filter).
+
+FFmpegInterop.CLR.cpp
+    This is the main DLL source file.
+
+FFmpegInterop.CLR.h
+    This file contains a class declaration.
+
+AssemblyInfo.cpp
+	Contains custom attributes for modifying assembly metadata.
+
+/////////////////////////////////////////////////////////////////////////////
+Other notes:
+
+AppWizard uses "TODO:" to indicate parts of the source code you
+should add to or customize.
+
+/////////////////////////////////////////////////////////////////////////////
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/Stdafx.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/Stdafx.cpp
new file mode 100644
index 0000000..d6869bc
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/Stdafx.cpp
@@ -0,0 +1,5 @@
+// stdafx.cpp : source file that includes just the standard includes
+// FFmpegInterop.CLR.pch will be the pre-compiled header
+// stdafx.obj will contain the pre-compiled type information
+
+#include "stdafx.h"
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/Stdafx.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/Stdafx.h
new file mode 100644
index 0000000..9f80576
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/Stdafx.h
@@ -0,0 +1,13 @@
+// stdafx.h : include file for standard system include files,
+// or project specific include files that are used frequently,
+// but are changed infrequently
+
+#pragma once
+
+// Disable debug string output on non-debug build
+#if !_DEBUG
+#define DebugMessage(x)
+#else
+#define DebugMessage(x) OutputDebugString(x)
+#endif
+
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/TestNativeClass.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/TestNativeClass.cpp
new file mode 100644
index 0000000..8d4a613
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/TestNativeClass.cpp
@@ -0,0 +1,17 @@
+#include "stdafx.h"
+#include "TestNativeClass.h"
+
+
+TestNativeClass::TestNativeClass()
+{
+}
+
+
+TestNativeClass::~TestNativeClass()
+{
+}
+
+HRESULT TestNativeClass::Test1(IStream * stream)
+{
+	return E_NOTIMPL;
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/TestNativeClass.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/TestNativeClass.h
new file mode 100644
index 0000000..bd0fb59
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/TestNativeClass.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include <ObjIdl.h>
+
+class TestNativeClass
+{
+public:
+	TestNativeClass();
+	virtual ~TestNativeClass();
+
+	static HRESULT Test1(IStream *stream);
+};
+
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedAudioSampleProvider.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedAudioSampleProvider.cpp
new file mode 100644
index 0000000..dd4c842
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedAudioSampleProvider.cpp
@@ -0,0 +1,149 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#include "pch.h"
+
+#include "UncompressedAudioSampleProvider.h"
+
+using namespace FFmpegInterop;
+
+// Minimum duration for uncompressed audio samples (50 ms)
+const LONGLONG MINAUDIOSAMPLEDURATION = 500000;
+
+UncompressedAudioSampleProvider::UncompressedAudioSampleProvider(
+	FFmpegReader^ reader,
+	AVFormatContext* avFormatCtx,
+	AVCodecContext* avCodecCtx)
+	: UncompressedSampleProvider(reader, avFormatCtx, avCodecCtx)
+	, m_pSwrCtx(nullptr)
+{
+}
+
+HRESULT UncompressedAudioSampleProvider::AllocateResources()
+{
+	HRESULT hr = S_OK;
+	hr = UncompressedSampleProvider::AllocateResources();
+	if (SUCCEEDED(hr))
+	{
+		// Set default channel layout when the value is unknown (0)
+		int64 inChannelLayout = m_pAvCodecCtx->channel_layout ? m_pAvCodecCtx->channel_layout : av_get_default_channel_layout(m_pAvCodecCtx->channels);
+		int64 outChannelLayout = av_get_default_channel_layout(m_pAvCodecCtx->channels);
+
+		// Set up resampler to convert any PCM format (e.g. AV_SAMPLE_FMT_FLTP) to AV_SAMPLE_FMT_S16 PCM format that is expected by Media Element.
+		// Additional logic can be added to avoid resampling PCM data that is already in AV_SAMPLE_FMT_S16_PCM.
+		m_pSwrCtx = swr_alloc_set_opts(
+			NULL,
+			outChannelLayout,
+			AV_SAMPLE_FMT_S16,
+			m_pAvCodecCtx->sample_rate,
+			inChannelLayout,
+			m_pAvCodecCtx->sample_fmt,
+			m_pAvCodecCtx->sample_rate,
+			0,
+			NULL);
+
+		if (!m_pSwrCtx)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		if (swr_init(m_pSwrCtx) < 0)
+		{
+			hr = E_FAIL;
+		}
+	}
+
+	return hr;
+}
+
+UncompressedAudioSampleProvider::~UncompressedAudioSampleProvider()
+{
+	if (m_pAvFrame)
+	{
+		av_frame_free(&m_pAvFrame);
+	}
+
+	// Free 
+	swr_free(&m_pSwrCtx);
+}
+
+HRESULT UncompressedAudioSampleProvider::WriteAVPacketToStream(DataWriter^ dataWriter, AVPacket* avPacket)
+{
+	// Because each packet can contain multiple frames, we have already written the packet to the stream
+	// during the decode stage.
+	return S_OK;
+}
+
+HRESULT UncompressedAudioSampleProvider::ProcessDecodedFrame(DataWriter^ dataWriter)
+{
+	// Resample uncompressed frame to AV_SAMPLE_FMT_S16 PCM format that is expected by Media Element
+	uint8_t *resampledData = nullptr;
+	unsigned int aBufferSize = av_samples_alloc(&resampledData, NULL, m_pAvFrame->channels, m_pAvFrame->nb_samples, AV_SAMPLE_FMT_S16, 0);
+	int resampledDataSize = swr_convert(m_pSwrCtx, &resampledData, aBufferSize, (const uint8_t **)m_pAvFrame->extended_data, m_pAvFrame->nb_samples);
+	auto aBuffer = ref new Platform::Array<uint8_t>(resampledData, min(aBufferSize, (unsigned int)(resampledDataSize * m_pAvFrame->channels * av_get_bytes_per_sample(AV_SAMPLE_FMT_S16))));
+	dataWriter->WriteBytes(aBuffer);
+	av_freep(&resampledData);
+	av_frame_unref(m_pAvFrame);
+	av_frame_free(&m_pAvFrame);
+
+	return S_OK;
+}
+
+MediaStreamSample^ UncompressedAudioSampleProvider::GetNextSample()
+{
+	// Similar to GetNextSample in MediaSampleProvider, 
+	// but we concatenate samples until reaching a minimum duration
+	DebugMessage(L"GetNextSample\n");
+
+	HRESULT hr = S_OK;
+
+	MediaStreamSample^ sample;
+	DataWriter^ dataWriter = ref new DataWriter();
+
+	LONGLONG finalPts = -1;
+	LONGLONG finalDur = 0;
+
+	do
+	{
+		LONGLONG pts = 0;
+		LONGLONG dur = 0;
+
+		hr = GetNextPacket(dataWriter, pts, dur);
+
+		if (SUCCEEDED(hr))
+		{
+			if (finalPts == -1)
+			{
+				finalPts = pts;
+			}
+			finalDur += dur;
+		}
+
+	} while (SUCCEEDED(hr) && finalDur < MINAUDIOSAMPLEDURATION);
+
+	if (finalDur > 0)
+	{
+		sample = MediaStreamSample::CreateFromBuffer(dataWriter->DetachBuffer(), { finalPts });
+		sample->Duration = { finalDur };
+	}
+
+	return sample;
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedAudioSampleProvider.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedAudioSampleProvider.h
new file mode 100644
index 0000000..8b4ae2c
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedAudioSampleProvider.h
@@ -0,0 +1,48 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#pragma once
+#include "UncompressedSampleProvider.h"
+
+extern "C"
+{
+#include <libswresample/swresample.h>
+}
+
+namespace FFmpegInterop
+{
+	ref class UncompressedAudioSampleProvider: UncompressedSampleProvider
+	{
+	public:
+		virtual ~UncompressedAudioSampleProvider();
+		virtual MediaStreamSample^ GetNextSample() override;
+
+	internal:
+		UncompressedAudioSampleProvider(
+			FFmpegReader^ reader,
+			AVFormatContext* avFormatCtx,
+			AVCodecContext* avCodecCtx);
+		virtual HRESULT WriteAVPacketToStream(DataWriter^ writer, AVPacket* avPacket) override;
+		virtual HRESULT ProcessDecodedFrame(DataWriter^ dataWriter) override;
+		virtual HRESULT AllocateResources() override;
+
+	private:
+		SwrContext* m_pSwrCtx;
+	};
+}
+
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedSampleProvider.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedSampleProvider.cpp
new file mode 100644
index 0000000..d3ddd49
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedSampleProvider.cpp
@@ -0,0 +1,123 @@
+//*****************************************************************************
+//
+//	Copyright 2016 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#include "pch.h"
+#include "UncompressedSampleProvider.h"
+
+using namespace FFmpegInterop;
+
+UncompressedSampleProvider::UncompressedSampleProvider(FFmpegReader^ reader, AVFormatContext* avFormatCtx, AVCodecContext* avCodecCtx)
+	: MediaSampleProvider(reader, avFormatCtx, avCodecCtx)
+	, m_pAvFrame(nullptr)
+{
+}
+
+HRESULT UncompressedSampleProvider::ProcessDecodedFrame(DataWriter^ dataWriter)
+{
+	return S_OK;
+}
+
+// Return S_FALSE for an incomplete frame
+HRESULT UncompressedSampleProvider::GetFrameFromFFmpegDecoder(AVPacket* avPacket)
+{
+	HRESULT hr = S_OK;
+	int decodeFrame = 0;
+
+	if (avPacket != nullptr)
+	{
+		int sendPacketResult = avcodec_send_packet(m_pAvCodecCtx, avPacket);
+		if (sendPacketResult == AVERROR(EAGAIN))
+		{
+			// The decoder should have been drained and always ready to access input
+			_ASSERT(FALSE);
+			hr = E_UNEXPECTED;
+		}
+		else if (sendPacketResult < 0)
+		{
+			// We failed to send the packet
+			hr = E_FAIL;
+			DebugMessage(L"Decoder failed on the sample\n");
+		}
+	}
+	if (SUCCEEDED(hr))
+	{
+		AVFrame *pFrame = av_frame_alloc();
+		// Try to get a frame from the decoder.
+		decodeFrame = avcodec_receive_frame(m_pAvCodecCtx, pFrame);
+
+		// The decoder is empty, send a packet to it.
+		if (decodeFrame == AVERROR(EAGAIN))
+		{
+			// The decoder doesn't have enough data to produce a frame,
+			// return S_FALSE to indicate a partial frame
+			hr = S_FALSE;
+			av_frame_unref(pFrame);
+			av_frame_free(&pFrame);
+		}
+		else if (decodeFrame < 0)
+		{
+			hr = E_FAIL;
+			av_frame_unref(pFrame);
+			av_frame_free(&pFrame);
+			DebugMessage(L"Failed to get a frame from the decoder\n");
+		}
+		else
+		{
+			m_pAvFrame = pFrame;
+		}
+	}
+
+	return hr;
+}
+
+HRESULT UncompressedSampleProvider::DecodeAVPacket(DataWriter^ dataWriter, AVPacket* avPacket, int64_t& framePts, int64_t& frameDuration)
+{
+	HRESULT hr = S_OK;
+	bool fGotFrame  = false;
+	AVPacket *pPacket = avPacket;
+
+	while (SUCCEEDED(hr))
+	{
+		hr = GetFrameFromFFmpegDecoder(pPacket);
+		pPacket = nullptr;
+		if (SUCCEEDED(hr))
+		{
+			if (hr == S_FALSE)
+			{
+				// If the decoder didn't give an initial frame we still need
+				// to feed it more frames. Keep S_FALSE as the result
+				if (fGotFrame)
+				{
+					hr = S_OK;
+				}
+				break;
+			}
+			// Update the timestamp if the packet has one
+			else if (m_pAvFrame->pts != AV_NOPTS_VALUE)
+			{
+				framePts = m_pAvFrame->pts;
+				frameDuration = m_pAvFrame->pkt_duration;
+			}
+			fGotFrame = true;
+
+			hr = ProcessDecodedFrame(dataWriter);
+		}
+	}
+
+	return hr;
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedSampleProvider.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedSampleProvider.h
new file mode 100644
index 0000000..c764438
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedSampleProvider.h
@@ -0,0 +1,45 @@
+//*****************************************************************************
+//
+//	Copyright 2016 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#pragma once
+#include "MediaSampleProvider.h"
+
+extern "C"
+{
+#include <libswresample/swresample.h>
+}
+
+namespace FFmpegInterop
+{
+	ref class UncompressedSampleProvider abstract : public MediaSampleProvider
+	{
+	internal:
+		// Try to get a frame from FFmpeg, otherwise, feed a frame to start decoding
+		virtual HRESULT GetFrameFromFFmpegDecoder(AVPacket* avPacket);
+		virtual HRESULT DecodeAVPacket(DataWriter^ dataWriter, AVPacket* avPacket, int64_t& framePts, int64_t& frameDuration) override;
+		virtual HRESULT ProcessDecodedFrame(DataWriter^ dataWriter);
+		UncompressedSampleProvider(
+			FFmpegReader^ reader,
+			AVFormatContext* avFormatCtx,
+			AVCodecContext* avCodecCtx);
+
+	internal:
+		AVFrame* m_pAvFrame;
+	};
+}
+
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedVideoSampleProvider.cpp b/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedVideoSampleProvider.cpp
new file mode 100644
index 0000000..92b6d90
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedVideoSampleProvider.cpp
@@ -0,0 +1,157 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#include "pch.h"
+#include "UncompressedVideoSampleProvider.h"
+#include <mfapi.h>
+
+extern "C"
+{
+#include <libavutil/imgutils.h>
+}
+
+
+using namespace FFmpegInterop;
+
+UncompressedVideoSampleProvider::UncompressedVideoSampleProvider(
+	FFmpegReader^ reader,
+	AVFormatContext* avFormatCtx,
+	AVCodecContext* avCodecCtx)
+	: UncompressedSampleProvider(reader, avFormatCtx, avCodecCtx)
+	, m_pSwsCtx(nullptr)
+{
+	for (int i = 0; i < 4; i++)
+	{
+		m_rgVideoBufferLineSize[i] = 0;
+		m_rgVideoBufferData[i] = nullptr;
+	}
+}
+
+HRESULT UncompressedVideoSampleProvider::AllocateResources()
+{
+	HRESULT hr = S_OK;
+	hr = UncompressedSampleProvider::AllocateResources();
+	if (SUCCEEDED(hr))
+	{
+		// Setup software scaler to convert any decoder pixel format (e.g. YUV420P) to NV12 that is supported in Windows & Windows Phone MediaElement
+		m_pSwsCtx = sws_getContext(
+			m_pAvCodecCtx->width,
+			m_pAvCodecCtx->height,
+			m_pAvCodecCtx->pix_fmt,
+			m_pAvCodecCtx->width,
+			m_pAvCodecCtx->height,
+			AV_PIX_FMT_NV12,
+			SWS_BICUBIC,
+			NULL,
+			NULL,
+			NULL);
+
+		if (m_pSwsCtx == nullptr)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		m_pAvFrame = av_frame_alloc();
+		if (m_pAvFrame == nullptr)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		if (av_image_alloc(m_rgVideoBufferData, m_rgVideoBufferLineSize, m_pAvCodecCtx->width, m_pAvCodecCtx->height, AV_PIX_FMT_NV12, 1) < 0)
+		{
+			hr = E_FAIL;
+		}
+	}
+
+	return hr;
+}
+
+UncompressedVideoSampleProvider::~UncompressedVideoSampleProvider()
+{
+	if (m_pAvFrame)
+	{
+		av_frame_free(&m_pAvFrame);
+	}
+
+	if (m_rgVideoBufferData)
+	{
+		av_freep(m_rgVideoBufferData);
+	}
+}
+
+HRESULT UncompressedVideoSampleProvider::DecodeAVPacket(DataWriter^ dataWriter, AVPacket* avPacket, int64_t& framePts, int64_t& frameDuration)
+{
+	HRESULT hr = S_OK;
+	hr = UncompressedSampleProvider::DecodeAVPacket(dataWriter, avPacket, framePts, frameDuration);
+
+	// Don't set a timestamp on S_FALSE
+	if (hr == S_OK)
+	{
+		// Try to get the best effort timestamp for the frame.
+		framePts = av_frame_get_best_effort_timestamp(m_pAvFrame);
+		m_interlaced_frame = m_pAvFrame->interlaced_frame == 1;
+		m_top_field_first = m_pAvFrame->top_field_first == 1;
+	}
+
+	return hr;
+}
+
+MediaStreamSample^ UncompressedVideoSampleProvider::GetNextSample()
+{
+	MediaStreamSample^ sample = MediaSampleProvider::GetNextSample();
+
+	if (sample != nullptr)
+	{
+		if (m_interlaced_frame)
+		{
+			sample->ExtendedProperties->Insert(MFSampleExtension_Interlaced, TRUE);
+			sample->ExtendedProperties->Insert(MFSampleExtension_BottomFieldFirst, m_top_field_first ? safe_cast<Platform::Object^>(FALSE) : TRUE);
+			sample->ExtendedProperties->Insert(MFSampleExtension_RepeatFirstField, safe_cast<Platform::Object^>(FALSE));
+		}
+		else
+		{
+			sample->ExtendedProperties->Insert(MFSampleExtension_Interlaced, safe_cast<Platform::Object^>(FALSE));
+		}
+	}
+
+	return sample;
+}
+
+HRESULT UncompressedVideoSampleProvider::WriteAVPacketToStream(DataWriter^ dataWriter, AVPacket* avPacket)
+{
+	// Convert decoded video pixel format to NV12 using FFmpeg software scaler
+	if (sws_scale(m_pSwsCtx, (const uint8_t **)(m_pAvFrame->data), m_pAvFrame->linesize, 0, m_pAvCodecCtx->height, m_rgVideoBufferData, m_rgVideoBufferLineSize) < 0)
+	{
+		return E_FAIL;
+	}
+
+	auto YBuffer = ref new Platform::Array<uint8_t>(m_rgVideoBufferData[0], m_rgVideoBufferLineSize[0] * m_pAvCodecCtx->height);
+	auto UVBuffer = ref new Platform::Array<uint8_t>(m_rgVideoBufferData[1], m_rgVideoBufferLineSize[1] * m_pAvCodecCtx->height / 2);
+	dataWriter->WriteBytes(YBuffer);
+	dataWriter->WriteBytes(UVBuffer);
+	av_frame_unref(m_pAvFrame);
+	av_frame_free(&m_pAvFrame);
+
+	return S_OK;
+}
diff --git a/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedVideoSampleProvider.h b/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedVideoSampleProvider.h
new file mode 100644
index 0000000..954982a
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.CLR/UncompressedVideoSampleProvider.h
@@ -0,0 +1,52 @@
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#pragma once
+#include "UncompressedSampleProvider.h"
+
+extern "C"
+{
+#include <libswscale/swscale.h>
+}
+
+
+namespace FFmpegInterop
+{
+	ref class UncompressedVideoSampleProvider: UncompressedSampleProvider
+	{
+	public:
+		virtual ~UncompressedVideoSampleProvider();
+		virtual MediaStreamSample^ GetNextSample() override;
+	internal:
+		UncompressedVideoSampleProvider(
+			FFmpegReader^ reader,
+			AVFormatContext* avFormatCtx,
+			AVCodecContext* avCodecCtx);
+		virtual HRESULT WriteAVPacketToStream(DataWriter^ writer, AVPacket* avPacket) override;
+		virtual HRESULT DecodeAVPacket(DataWriter^ dataWriter, AVPacket* avPacket, int64_t& framePts, int64_t& frameDuration) override;
+		virtual HRESULT AllocateResources() override;
+
+	private:
+		SwsContext* m_pSwsCtx;
+		int m_rgVideoBufferLineSize[4];
+		uint8_t* m_rgVideoBufferData[4];
+		bool m_interlaced_frame;
+		bool m_top_field_first;
+	};
+}
+
diff --git a/FFmpegInterop/CLR/FFmpegInterop.Shared2/FFmpegInterop.Shared2.vcxitems b/FFmpegInterop/CLR/FFmpegInterop.Shared2/FFmpegInterop.Shared2.vcxitems
new file mode 100644
index 0000000..8d2b768
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.Shared2/FFmpegInterop.Shared2.vcxitems
@@ -0,0 +1,46 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup Label="Globals">
+    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
+    <HasSharedItems>true</HasSharedItems>
+    <ItemsProjectGuid>{867383F4-6BEA-4998-B622-5D183301993A}</ItemsProjectGuid>
+    <ItemsRootNamespace>FFmpeg</ItemsRootNamespace>
+    <ItemsProjectName>FFmpegInterop.Shared2</ItemsProjectName>
+    <CodeSharingProject>27F3F5F7-76F4-4EC4-9BA0-139FB851B20F</CodeSharingProject>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories);$(MSBuildThisFileDirectory)</AdditionalIncludeDirectories>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\FFmpegInteropLogging.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\FFmpegInteropMSS.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\FFmpegReader.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\H264AVCSampleProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\H264SampleProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\ILogProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\MediaSampleProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\UncompressedAudioSampleProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\UncompressedSampleProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\UncompressedVideoSampleProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)pch.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\FFmpegInteropLogging.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\FFmpegInteropMSS.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\FFmpegReader.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\H264AVCSampleProvider.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\H264SampleProvider.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\MediaSampleProvider.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\UncompressedAudioSampleProvider.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\UncompressedSampleProvider.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\UncompressedVideoSampleProvider.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)pch.cpp">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectCapability Include="SourceItemsFromImports" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/FFmpegInterop/CLR/FFmpegInterop.Shared2/FFmpegInterop.Shared2.vcxitems.filters b/FFmpegInterop/CLR/FFmpegInterop.Shared2/FFmpegInterop.Shared2.vcxitems.filters
new file mode 100644
index 0000000..c3eee42
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.Shared2/FFmpegInterop.Shared2.vcxitems.filters
@@ -0,0 +1,30 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <ClInclude Include="$(MSBuildThisFileDirectory)pch.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\FFmpegInteropMSS.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\FFmpegReader.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\H264SampleProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\MediaSampleProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\UncompressedAudioSampleProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\UncompressedSampleProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\UncompressedVideoSampleProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\H264AVCSampleProvider.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\FFmpegInteropLogging.h" />
+    <ClInclude Include="$(MSBuildThisFileDirectory)..\..\Source\ILogProvider.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="$(MSBuildThisFileDirectory)pch.cpp">
+      <PrecompiledHeader>Create</PrecompiledHeader>
+    </ClCompile>
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\FFmpegInteropMSS.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\FFmpegReader.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\H264SampleProvider.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\MediaSampleProvider.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\UncompressedAudioSampleProvider.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\UncompressedSampleProvider.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\UncompressedVideoSampleProvider.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\H264AVCSampleProvider.cpp" />
+    <ClCompile Include="$(MSBuildThisFileDirectory)..\..\Source\FFmpegInteropLogging.cpp" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/FFmpegInterop/CLR/FFmpegInterop.Shared2/pch.cpp b/FFmpegInterop/CLR/FFmpegInterop.Shared2/pch.cpp
new file mode 100644
index 0000000..c66dd80
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.Shared2/pch.cpp
@@ -0,0 +1,19 @@
+﻿//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#include "pch.h"
diff --git a/FFmpegInterop/CLR/FFmpegInterop.Shared2/pch.h b/FFmpegInterop/CLR/FFmpegInterop.Shared2/pch.h
new file mode 100644
index 0000000..f9f1e7f
--- /dev/null
+++ b/FFmpegInterop/CLR/FFmpegInterop.Shared2/pch.h
@@ -0,0 +1,29 @@
+﻿//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#pragma once
+
+#include <collection.h>
+#include <ppltasks.h>
+
+// Disable debug string output on non-debug build
+#if !_DEBUG
+#define DebugMessage(x)
+#else
+#define DebugMessage(x) OutputDebugString(x)
+#endif
\ No newline at end of file
diff --git a/FFmpegInterop/Source/FFmpegInteropMSS.cpp b/FFmpegInterop/Source/FFmpegInteropMSS.cpp
index 1903eb6..79e8fda 100644
--- a/FFmpegInterop/Source/FFmpegInteropMSS.cpp
+++ b/FFmpegInterop/Source/FFmpegInteropMSS.cpp
@@ -1,100 +1,112 @@
-//*****************************************************************************
-//
-//	Copyright 2015 Microsoft Corporation
-//
-//	Licensed under the Apache License, Version 2.0 (the "License");
-//	you may not use this file except in compliance with the License.
-//	You may obtain a copy of the License at
-//
-//	http ://www.apache.org/licenses/LICENSE-2.0
-//
-//	Unless required by applicable law or agreed to in writing, software
-//	distributed under the License is distributed on an "AS IS" BASIS,
-//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-//	See the License for the specific language governing permissions and
-//	limitations under the License.
-//
-//*****************************************************************************
-
-#include "pch.h"
-#include "FFmpegInteropMSS.h"
-#include "MediaSampleProvider.h"
-#include "H264AVCSampleProvider.h"
-#include "H264SampleProvider.h"
-#include "UncompressedAudioSampleProvider.h"
-#include "UncompressedVideoSampleProvider.h"
-#include "shcore.h"
-#include <mfapi.h>
-
-extern "C"
-{
-#include <libavutil/imgutils.h>
-}
-
-using namespace concurrency;
-using namespace FFmpegInterop;
-using namespace Platform;
-using namespace Windows::Storage::Streams;
-using namespace Windows::Media::MediaProperties;
-
-// Size of the buffer when reading a stream
-const int FILESTREAMBUFFERSZ = 16384;
-
-// Static functions passed to FFmpeg for stream interop
-static int FileStreamRead(void* ptr, uint8_t* buf, int bufSize);
-static int64_t FileStreamSeek(void* ptr, int64_t pos, int whence);
-
-// Initialize an FFmpegInteropObject
-FFmpegInteropMSS::FFmpegInteropMSS()
-	: avDict(nullptr)
-	, avIOCtx(nullptr)
-	, avFormatCtx(nullptr)
-	, avAudioCodecCtx(nullptr)
-	, avVideoCodecCtx(nullptr)
-	, audioStreamIndex(AVERROR_STREAM_NOT_FOUND)
-	, videoStreamIndex(AVERROR_STREAM_NOT_FOUND)
-	, thumbnailStreamIndex(AVERROR_STREAM_NOT_FOUND)
-	, fileStreamData(nullptr)
-	, fileStreamBuffer(nullptr)
-{
-	av_register_all();
-}
-
-FFmpegInteropMSS::~FFmpegInteropMSS()
-{
-	mutexGuard.lock();
-	if (mss)
-	{
-		mss->Starting -= startingRequestedToken;
-		mss->SampleRequested -= sampleRequestedToken;
-		mss = nullptr;
-	}
-
-	// Clear our data
-	audioSampleProvider = nullptr;
-	videoSampleProvider = nullptr;
-
-	if (m_pReader != nullptr)
-	{
-		m_pReader->SetAudioStream(AVERROR_STREAM_NOT_FOUND, nullptr);
-		m_pReader->SetVideoStream(AVERROR_STREAM_NOT_FOUND, nullptr);
-		m_pReader = nullptr;
-	}
-
-	avcodec_close(avVideoCodecCtx);
-	avcodec_close(avAudioCodecCtx);
-	avformat_close_input(&avFormatCtx);
-	av_free(avIOCtx);
-	av_dict_free(&avDict);
-	
-	if (fileStreamData != nullptr)
-	{
-		fileStreamData->Release();
-	}
-	mutexGuard.unlock();
-}
-
-FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss)
+//*****************************************************************************
+//
+//	Copyright 2015 Microsoft Corporation
+//
+//	Licensed under the Apache License, Version 2.0 (the "License");
+//	you may not use this file except in compliance with the License.
+//	You may obtain a copy of the License at
+//
+//	http ://www.apache.org/licenses/LICENSE-2.0
+//
+//	Unless required by applicable law or agreed to in writing, software
+//	distributed under the License is distributed on an "AS IS" BASIS,
+//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+//	See the License for the specific language governing permissions and
+//	limitations under the License.
+//
+//*****************************************************************************
+
+#include "pch.h"
+#include "FFmpegInteropMSS.h"
+#include "MediaSampleProvider.h"
+#include "H264AVCSampleProvider.h"
+#include "H264SampleProvider.h"
+#include "UncompressedAudioSampleProvider.h"
+#include "UncompressedVideoSampleProvider.h"
+#include "shcore.h"
+#include <mfapi.h>
+
+extern "C"
+{
+#include <libavutil/imgutils.h>
+}
+
+using namespace concurrency;
+using namespace FFmpegInterop;
+using namespace Platform;
+using namespace Windows::Storage::Streams;
+using namespace Windows::Media::MediaProperties;
+
+// Size of the buffer when reading a stream
+const int FILESTREAMBUFFERSZ = 16384;
+
+// Static functions passed to FFmpeg for stream interop
+static int FileStreamRead(void* ptr, uint8_t* buf, int bufSize);
+static int64_t FileStreamSeek(void* ptr, int64_t pos, int whence);
+
+// Initialize an FFmpegInteropObject
+FFmpegInteropMSS::FFmpegInteropMSS()
+	: avDict(nullptr)
+	, avIOCtx(nullptr)
+	, avFormatCtx(nullptr)
+	, avAudioCodecCtx(nullptr)
+	, avVideoCodecCtx(nullptr)
+	, audioStreamIndex(AVERROR_STREAM_NOT_FOUND)
+	, videoStreamIndex(AVERROR_STREAM_NOT_FOUND)
+	, thumbnailStreamIndex(AVERROR_STREAM_NOT_FOUND)
+	, fileStreamData(nullptr)
+	, fileStreamBuffer(nullptr)
+{
+	av_register_all();
+}
+
+FFmpegInteropMSS::~FFmpegInteropMSS()
+{
+	mutexGuard.lock();
+	if (mss)
+	{
+		mss->Starting -= startingRequestedToken;
+		mss->SampleRequested -= sampleRequestedToken;
+		mss = nullptr;
+	}
+
+	// Clear our data
+	audioSampleProvider = nullptr;
+	videoSampleProvider = nullptr;
+
+	if (m_pReader != nullptr)
+	{
+		m_pReader->SetAudioStream(AVERROR_STREAM_NOT_FOUND, nullptr);
+		m_pReader->SetVideoStream(AVERROR_STREAM_NOT_FOUND, nullptr);
+		m_pReader = nullptr;
+	}
+
+	avcodec_close(avVideoCodecCtx);
+	avcodec_close(avAudioCodecCtx);
+	avformat_close_input(&avFormatCtx);
+	av_free(avIOCtx);
+	av_dict_free(&avDict);
+	
+	if (fileStreamData != nullptr)
+	{
+		fileStreamData->Release();
+	}
+	mutexGuard.unlock();
+}
+
+FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss)
+{
+	auto interopMSS = ref new FFmpegInteropMSS();
+	if (FAILED(interopMSS->CreateMediaStreamSource(stream, forceAudioDecode, forceVideoDecode, ffmpegOptions, mss)))
+	{
+		// We failed to initialize, clear the variable to return failure
+		interopMSS = nullptr;
+	}
+
+	return interopMSS;
+}
+/*
+FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(IStream* stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss)
 {
 	auto interopMSS = ref new FFmpegInteropMSS();
 	if (FAILED(interopMSS->CreateMediaStreamSource(stream, forceAudioDecode, forceVideoDecode, ffmpegOptions, mss)))
@@ -105,94 +117,175 @@ FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(IRandomAcce
 
 	return interopMSS;
 }
-
-FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions)
-{
-	return CreateFFmpegInteropMSSFromStream(stream, forceAudioDecode, forceVideoDecode, nullptr, nullptr);
-}
-
-FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode)
-{
-	return CreateFFmpegInteropMSSFromStream(stream, forceAudioDecode, forceVideoDecode, nullptr);
-}
-
-FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromUri(String^ uri, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions)
-{
-	auto interopMSS = ref new FFmpegInteropMSS();
-	if (FAILED(interopMSS->CreateMediaStreamSource(uri, forceAudioDecode, forceVideoDecode, ffmpegOptions)))
-	{
-		// We failed to initialize, clear the variable to return failure
-		interopMSS = nullptr;
-	}
-
-	return interopMSS;
-}
-
-FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromUri(String^ uri, bool forceAudioDecode, bool forceVideoDecode)
-{
-	return CreateFFmpegInteropMSSFromUri(uri, forceAudioDecode, forceVideoDecode, nullptr);
-}
-
-MediaStreamSource^ FFmpegInteropMSS::GetMediaStreamSource()
-{
-	return mss;
-}
-
-HRESULT FFmpegInteropMSS::CreateMediaStreamSource(String^ uri, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions)
-{
-	HRESULT hr = S_OK;
-	const char* charStr = nullptr;
-	if (!uri)
-	{
-		hr = E_INVALIDARG;
-	}
-
-	if (SUCCEEDED(hr))
-	{
-		avFormatCtx = avformat_alloc_context();
-		if (avFormatCtx == nullptr)
-		{
-			hr = E_OUTOFMEMORY;
-		}
-	}
-
-	if (SUCCEEDED(hr))
-	{
-		// Populate AVDictionary avDict based on PropertySet ffmpegOptions. List of options can be found in https://www.ffmpeg.org/ffmpeg-protocols.html
-		hr = ParseOptions(ffmpegOptions);
-	}
-
-	if (SUCCEEDED(hr))
-	{
-		std::wstring uriW(uri->Begin());
-		std::string uriA(uriW.begin(), uriW.end());
-		charStr = uriA.c_str();
-
-		// Open media in the given URI using the specified options
-		if (avformat_open_input(&avFormatCtx, charStr, NULL, &avDict) < 0)
-		{
-			hr = E_FAIL; // Error opening file
-		}
-
-		// avDict is not NULL only when there is an issue with the given ffmpegOptions such as invalid key, value type etc. Iterate through it to see which one is causing the issue.
-		if (avDict != nullptr)
-		{
-			DebugMessage(L"Invalid FFmpeg option(s)");
-			av_dict_free(&avDict);
-			avDict = nullptr;
-		}
-	}
-
-	if (SUCCEEDED(hr))
-	{
-		this->mss = nullptr;
-		hr = InitFFmpegContext(forceAudioDecode, forceVideoDecode);
-	}
-
-	return hr;
-}
-
-HRESULT FFmpegInteropMSS::CreateMediaStreamSource(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss)
+*/
+
+
+FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions)
+{
+	return CreateFFmpegInteropMSSFromStream(stream, forceAudioDecode, forceVideoDecode, nullptr, nullptr);
+}
+
+FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromStream(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode)
+{
+	return CreateFFmpegInteropMSSFromStream(stream, forceAudioDecode, forceVideoDecode, nullptr);
+}
+
+FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromUri(String^ uri, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions)
+{
+	auto interopMSS = ref new FFmpegInteropMSS();
+	if (FAILED(interopMSS->CreateMediaStreamSource(uri, forceAudioDecode, forceVideoDecode, ffmpegOptions)))
+	{
+		// We failed to initialize, clear the variable to return failure
+		interopMSS = nullptr;
+	}
+
+	return interopMSS;
+}
+
+FFmpegInteropMSS^ FFmpegInteropMSS::CreateFFmpegInteropMSSFromUri(String^ uri, bool forceAudioDecode, bool forceVideoDecode)
+{
+	return CreateFFmpegInteropMSSFromUri(uri, forceAudioDecode, forceVideoDecode, nullptr);
+}
+
+MediaStreamSource^ FFmpegInteropMSS::GetMediaStreamSource()
+{
+	return mss;
+}
+
+HRESULT FFmpegInteropMSS::CreateMediaStreamSource(String^ uri, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions)
+{
+	HRESULT hr = S_OK;
+	const char* charStr = nullptr;
+	if (!uri)
+	{
+		hr = E_INVALIDARG;
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		avFormatCtx = avformat_alloc_context();
+		if (avFormatCtx == nullptr)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Populate AVDictionary avDict based on PropertySet ffmpegOptions. List of options can be found in https://www.ffmpeg.org/ffmpeg-protocols.html
+		hr = ParseOptions(ffmpegOptions);
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		std::wstring uriW(uri->Begin());
+		std::string uriA(uriW.begin(), uriW.end());
+		charStr = uriA.c_str();
+
+		// Open media in the given URI using the specified options
+		if (avformat_open_input(&avFormatCtx, charStr, NULL, &avDict) < 0)
+		{
+			hr = E_FAIL; // Error opening file
+		}
+
+		// avDict is not NULL only when there is an issue with the given ffmpegOptions such as invalid key, value type etc. Iterate through it to see which one is causing the issue.
+		if (avDict != nullptr)
+		{
+			DebugMessage(L"Invalid FFmpeg option(s)");
+			av_dict_free(&avDict);
+			avDict = nullptr;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		this->mss = nullptr;
+		hr = InitFFmpegContext(forceAudioDecode, forceVideoDecode);
+	}
+
+	return hr;
+}
+
+HRESULT FFmpegInteropMSS::CreateMediaStreamSource(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss)
+{
+	HRESULT hr = S_OK;
+	if (!stream)
+	{
+		hr = E_INVALIDARG;
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Convert asynchronous IRandomAccessStream to synchronous IStream. This API requires shcore.h and shcore.lib
+		hr = CreateStreamOverRandomAccessStream(reinterpret_cast<IUnknown*>(stream), IID_PPV_ARGS(&fileStreamData));
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Setup FFmpeg custom IO to access file as stream. This is necessary when accessing any file outside of app installation directory and appdata folder.
+		// Credit to Philipp Sch http://www.codeproject.com/Tips/489450/Creating-Custom-FFmpeg-IO-Context
+		fileStreamBuffer = (unsigned char*)av_malloc(FILESTREAMBUFFERSZ);
+		if (fileStreamBuffer == nullptr)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		avIOCtx = avio_alloc_context(fileStreamBuffer, FILESTREAMBUFFERSZ, 0, fileStreamData, FileStreamRead, 0, FileStreamSeek);
+		if (avIOCtx == nullptr)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		avFormatCtx = avformat_alloc_context();
+		if (avFormatCtx == nullptr)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Populate AVDictionary avDict based on PropertySet ffmpegOptions. List of options can be found in https://www.ffmpeg.org/ffmpeg-protocols.html
+		hr = ParseOptions(ffmpegOptions);
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		avFormatCtx->pb = avIOCtx;
+		avFormatCtx->flags |= AVFMT_FLAG_CUSTOM_IO;
+
+		// Open media file using custom IO setup above instead of using file name. Opening a file using file name will invoke fopen C API call that only have
+		// access within the app installation directory and appdata folder. Custom IO allows access to file selected using FilePicker dialog.
+		if (avformat_open_input(&avFormatCtx, "", NULL, &avDict) < 0)
+		{
+			hr = E_FAIL; // Error opening file
+		}
+
+		// avDict is not NULL only when there is an issue with the given ffmpegOptions such as invalid key, value type etc. Iterate through it to see which one is causing the issue.
+		if (avDict != nullptr)
+		{
+			DebugMessage(L"Invalid FFmpeg option(s)");
+			av_dict_free(&avDict);
+			avDict = nullptr;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		this->mss = mss;
+		hr = InitFFmpegContext(forceAudioDecode, forceVideoDecode);
+	}
+
+	return hr;
+}
+
+HRESULT FFmpegInteropMSS::CreateMediaStreamSource(IStream* stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss)
 {
 	HRESULT hr = S_OK;
 	if (!stream)
@@ -200,11 +293,13 @@ HRESULT FFmpegInteropMSS::CreateMediaStreamSource(IRandomAccessStream^ stream, b
 		hr = E_INVALIDARG;
 	}
 
-	if (SUCCEEDED(hr))
-	{
-		// Convert asynchronous IRandomAccessStream to synchronous IStream. This API requires shcore.h and shcore.lib
-		hr = CreateStreamOverRandomAccessStream(reinterpret_cast<IUnknown*>(stream), IID_PPV_ARGS(&fileStreamData));
-	}
+	//if (SUCCEEDED(hr))
+	//{
+	//	// Convert asynchronous IRandomAccessStream to synchronous IStream. This API requires shcore.h and shcore.lib
+	//	hr = CreateStreamOverRandomAccessStream(reinterpret_cast<IUnknown*>(stream), IID_PPV_ARGS(&fileStreamData));
+	//}
+
+	fileStreamData = stream;
 
 	if (SUCCEEDED(hr))
 	{
@@ -269,508 +364,512 @@ HRESULT FFmpegInteropMSS::CreateMediaStreamSource(IRandomAccessStream^ stream, b
 	}
 
 	return hr;
-}
-
-HRESULT FFmpegInteropMSS::InitFFmpegContext(bool forceAudioDecode, bool forceVideoDecode)
-{
-	HRESULT hr = S_OK;
 
-	if (SUCCEEDED(hr))
-	{
-		if (avformat_find_stream_info(avFormatCtx, NULL) < 0)
-		{
-			hr = E_FAIL; // Error finding info
-		}
-	}
-
-	if (SUCCEEDED(hr))
-	{
-		m_pReader = ref new FFmpegReader(avFormatCtx);
-		if (m_pReader == nullptr)
-		{
-			hr = E_OUTOFMEMORY;
-		}
-	}
-
-	if (SUCCEEDED(hr))
-	{
-		// Find the audio stream and its decoder
-		AVCodec* avAudioCodec = nullptr;
-		audioStreamIndex = av_find_best_stream(avFormatCtx, AVMEDIA_TYPE_AUDIO, -1, -1, &avAudioCodec, 0);
-		if (audioStreamIndex != AVERROR_STREAM_NOT_FOUND && avAudioCodec)
-		{
-			// allocate a new decoding context
-			avAudioCodecCtx = avcodec_alloc_context3(avAudioCodec);
-			if (!avAudioCodecCtx)
-			{
-				hr = E_OUTOFMEMORY;
-				DebugMessage(L"Could not allocate a decoding context\n");
-				avformat_close_input(&avFormatCtx);
-			}
-
-			if (SUCCEEDED(hr))
-			{
-				// initialize the stream parameters with demuxer information
-				if (avcodec_parameters_to_context(avAudioCodecCtx, avFormatCtx->streams[audioStreamIndex]->codecpar) < 0)
-				{
-					hr = E_FAIL;
-					avformat_close_input(&avFormatCtx);
-					avcodec_free_context(&avAudioCodecCtx);
-				}
-
-				if (SUCCEEDED(hr))
-				{
-					if (avcodec_open2(avAudioCodecCtx, avAudioCodec, NULL) < 0)
-					{
-						avAudioCodecCtx = nullptr;
-						hr = E_FAIL;
-					}
-					else
-					{
-						// Detect audio format and create audio stream descriptor accordingly
-						hr = CreateAudioStreamDescriptor(forceAudioDecode);
-						if (SUCCEEDED(hr))
-						{
-							hr = audioSampleProvider->AllocateResources();
-							if (SUCCEEDED(hr))
-							{
-								m_pReader->SetAudioStream(audioStreamIndex, audioSampleProvider);
-							}
-						}
-
-						if (SUCCEEDED(hr))
-						{
-							// Convert audio codec name for property
-							hr = ConvertCodecName(avAudioCodec->name, &audioCodecName);
-						}
-					}
-				}
-			}
-		}
-	}
-
-	if (SUCCEEDED(hr))
-	{
-		// Find the video stream and its decoder
-		AVCodec* avVideoCodec = nullptr;
-		videoStreamIndex = av_find_best_stream(avFormatCtx, AVMEDIA_TYPE_VIDEO, -1, -1, &avVideoCodec, 0);
-		if (videoStreamIndex != AVERROR_STREAM_NOT_FOUND && avVideoCodec)
-		{
-			// FFmpeg identifies album/cover art from a music file as a video stream
-			// Avoid creating unnecessarily video stream from this album/cover art
-			if (avFormatCtx->streams[videoStreamIndex]->disposition == AV_DISPOSITION_ATTACHED_PIC)
-			{
-				thumbnailStreamIndex = videoStreamIndex;
-				videoStreamIndex = AVERROR_STREAM_NOT_FOUND;
-				avVideoCodec = nullptr;
-			}
-			else
-			{
-				thumbnailStreamIndex = AVERROR_STREAM_NOT_FOUND;
-				AVDictionaryEntry *rotate_tag = av_dict_get(avFormatCtx->streams[videoStreamIndex]->metadata, "rotate", NULL, 0);
-				if (rotate_tag != NULL)
-				{
-					rotateVideo = true;
-					rotationAngle = atoi(rotate_tag->value);
-				}
-				else
-				{
-					rotateVideo = false;
-				}
-				// allocate a new decoding context
-				avVideoCodecCtx = avcodec_alloc_context3(avVideoCodec);
-				if (!avVideoCodecCtx)
-				{
-					DebugMessage(L"Could not allocate a decoding context\n");
-					avformat_close_input(&avFormatCtx);
-					hr = E_OUTOFMEMORY;
-				}
-
-				if (SUCCEEDED(hr))
-				{
-					// initialize the stream parameters with demuxer information
-					if (avcodec_parameters_to_context(avVideoCodecCtx, avFormatCtx->streams[videoStreamIndex]->codecpar) < 0)
-					{
-						avformat_close_input(&avFormatCtx);
-						avcodec_free_context(&avVideoCodecCtx);
-						hr = E_FAIL;
-					}
-				}
-
-				if (SUCCEEDED(hr))
-				{
-					if (avcodec_open2(avVideoCodecCtx, avVideoCodec, NULL) < 0)
-					{
-						avVideoCodecCtx = nullptr;
-						hr = E_FAIL; // Cannot open the video codec
-					}
-					else
-					{
-						// Detect video format and create video stream descriptor accordingly
-						hr = CreateVideoStreamDescriptor(forceVideoDecode);
-						if (SUCCEEDED(hr))
-						{
-							hr = videoSampleProvider->AllocateResources();
-							if (SUCCEEDED(hr))
-							{
-								m_pReader->SetVideoStream(videoStreamIndex, videoSampleProvider);
-							}
-						}
-
-						if (SUCCEEDED(hr))
-						{
-							// Convert video codec name for property
-							hr = ConvertCodecName(avVideoCodec->name, &videoCodecName);
-						}
-					}
-				}
-			}
-		}
-	}
-
-	if (SUCCEEDED(hr))
-	{
-		// Convert media duration from AV_TIME_BASE to TimeSpan unit
-		mediaDuration = { LONGLONG(avFormatCtx->duration * 10000000 / double(AV_TIME_BASE)) };
-
-		if (audioStreamDescriptor)
-		{
-			if (videoStreamDescriptor)
-			{
-				if (mss)
-				{
-					mss->AddStreamDescriptor(videoStreamDescriptor);
-					mss->AddStreamDescriptor(audioStreamDescriptor);
-				}
-				else
-				{
-					mss = ref new MediaStreamSource(videoStreamDescriptor, audioStreamDescriptor);
-				}
-			}
-			else
-			{
-				if (mss)
-				{
-					mss->AddStreamDescriptor(audioStreamDescriptor);
-				}
-				else
-				{
-					mss = ref new MediaStreamSource(audioStreamDescriptor);
-				}
-			}
-		}
-		else if (videoStreamDescriptor)
-		{
-			if (mss)
-			{
-				mss->AddStreamDescriptor(videoStreamDescriptor);
-			}
-			else
-			{
-				mss = ref new MediaStreamSource(videoStreamDescriptor);
-			}
-		}
-		if (mss)
-		{
-			if (mediaDuration.Duration > 0)
-			{
-				mss->Duration = mediaDuration;
-				mss->CanSeek = true;
-			}
-			else
-			{
-				// Set buffer time to 0 for realtime streaming to reduce latency
-				mss->BufferTime = { 0 };
-			}
-
-			startingRequestedToken = mss->Starting += ref new TypedEventHandler<MediaStreamSource ^, MediaStreamSourceStartingEventArgs ^>(this, &FFmpegInteropMSS::OnStarting);
-			sampleRequestedToken = mss->SampleRequested += ref new TypedEventHandler<MediaStreamSource ^, MediaStreamSourceSampleRequestedEventArgs ^>(this, &FFmpegInteropMSS::OnSampleRequested);
-		}
-		else
-		{
-			hr = E_OUTOFMEMORY;
-		}
-	}
-
-	return hr;
-}
-
-MediaThumbnailData ^ FFmpegInterop::FFmpegInteropMSS::ExtractThumbnail()
-{
-	if (thumbnailStreamIndex != AVERROR_STREAM_NOT_FOUND)
-	{
-		// FFmpeg identifies album/cover art from a music file as a video stream
-		// Avoid creating unnecessarily video stream from this album/cover art
-		if (avFormatCtx->streams[thumbnailStreamIndex]->disposition == AV_DISPOSITION_ATTACHED_PIC)
-		{
-			auto imageStream = avFormatCtx->streams[thumbnailStreamIndex];
-			//save album art to file.
-			String^ extension = ".jpeg";
-			switch (imageStream->codecpar->codec_id)
-			{
-			case AV_CODEC_ID_MJPEG:
-			case AV_CODEC_ID_MJPEGB:
-			case AV_CODEC_ID_JPEG2000:
-			case AV_CODEC_ID_JPEGLS: extension = ".jpeg"; break;
-			case AV_CODEC_ID_PNG: extension = ".png"; break;
-			case AV_CODEC_ID_BMP: extension = ".bmp"; break;
-			}
-
-
-			auto vector = ref new Array<uint8_t>(imageStream->attached_pic.data, imageStream->attached_pic.size);
-			DataWriter^ writer = ref new DataWriter();
-			writer->WriteBytes(vector);
-
-			return (ref new MediaThumbnailData(writer->DetachBuffer(), extension));
-		}
-	}
-
-	return nullptr;
-}
-
-HRESULT FFmpegInteropMSS::ConvertCodecName(const char* codecName, String^ *outputCodecName)
-{
-	HRESULT hr = S_OK;
-
-	// Convert codec name from const char* to Platform::String
-	auto codecNameChars = codecName;
-	size_t newsize = strlen(codecNameChars) + 1;
-	wchar_t * wcstring = new(std::nothrow) wchar_t[newsize];
-	if (wcstring == nullptr)
-	{
-		hr = E_OUTOFMEMORY;
-	}
-
-	if (SUCCEEDED(hr))
-	{
-		size_t convertedChars = 0;
-		mbstowcs_s(&convertedChars, wcstring, newsize, codecNameChars, _TRUNCATE);
-		*outputCodecName = ref new Platform::String(wcstring);
-		delete[] wcstring;
-	}
-
-	return hr;
 }
 
-HRESULT FFmpegInteropMSS::CreateAudioStreamDescriptor(bool forceAudioDecode)
-{
-	if (avAudioCodecCtx->codec_id == AV_CODEC_ID_AAC && !forceAudioDecode)
-	{
-		if (avAudioCodecCtx->extradata_size == 0)
-		{
-			audioStreamDescriptor = ref new AudioStreamDescriptor(AudioEncodingProperties::CreateAacAdts(avAudioCodecCtx->sample_rate, avAudioCodecCtx->channels, (unsigned int)avAudioCodecCtx->bit_rate));
-		}
-		else
-		{
-			audioStreamDescriptor = ref new AudioStreamDescriptor(AudioEncodingProperties::CreateAac(avAudioCodecCtx->sample_rate, avAudioCodecCtx->channels, (unsigned int)avAudioCodecCtx->bit_rate));
-		}
-		audioSampleProvider = ref new MediaSampleProvider(m_pReader, avFormatCtx, avAudioCodecCtx);
-	}
-	else if (avAudioCodecCtx->codec_id == AV_CODEC_ID_MP3 && !forceAudioDecode)
-	{
-		audioStreamDescriptor = ref new AudioStreamDescriptor(AudioEncodingProperties::CreateMp3(avAudioCodecCtx->sample_rate, avAudioCodecCtx->channels, (unsigned int)avAudioCodecCtx->bit_rate));
-		audioSampleProvider = ref new MediaSampleProvider(m_pReader, avFormatCtx, avAudioCodecCtx);
-	}
-	else
-	{
-		// We always convert to 16-bit audio so set the size here
-		audioStreamDescriptor = ref new AudioStreamDescriptor(AudioEncodingProperties::CreatePcm(avAudioCodecCtx->sample_rate, avAudioCodecCtx->channels, 16));
-		audioSampleProvider = ref new UncompressedAudioSampleProvider(m_pReader, avFormatCtx, avAudioCodecCtx);
-	}
 
-	return (audioStreamDescriptor != nullptr && audioSampleProvider != nullptr) ? S_OK : E_OUTOFMEMORY;
-}
-
-HRESULT FFmpegInteropMSS::CreateVideoStreamDescriptor(bool forceVideoDecode)
-{
-	VideoEncodingProperties^ videoProperties;
-
-	if (avVideoCodecCtx->codec_id == AV_CODEC_ID_H264 && !forceVideoDecode)
-	{
-		videoProperties = VideoEncodingProperties::CreateH264();
-		videoProperties->ProfileId = avVideoCodecCtx->profile;
-		videoProperties->Height = avVideoCodecCtx->height;
-		videoProperties->Width = avVideoCodecCtx->width;
-
-		// Check for H264 bitstream flavor. H.264 AVC extradata starts with 1 while non AVC one starts with 0
-		if (avVideoCodecCtx->extradata != nullptr && avVideoCodecCtx->extradata_size > 0 && avVideoCodecCtx->extradata[0] == 1)
-		{
-			videoSampleProvider = ref new H264AVCSampleProvider(m_pReader, avFormatCtx, avVideoCodecCtx);
-		}
-		else
-		{
-			videoSampleProvider = ref new H264SampleProvider(m_pReader, avFormatCtx, avVideoCodecCtx);
-		}
-	}
-	else
-	{
-		videoProperties = VideoEncodingProperties::CreateUncompressed(MediaEncodingSubtypes::Nv12, avVideoCodecCtx->width, avVideoCodecCtx->height);
-		videoSampleProvider = ref new UncompressedVideoSampleProvider(m_pReader, avFormatCtx, avVideoCodecCtx);
-
-		if (avVideoCodecCtx->sample_aspect_ratio.num > 0 && avVideoCodecCtx->sample_aspect_ratio.den != 0)
-		{
-			videoProperties->PixelAspectRatio->Numerator = avVideoCodecCtx->sample_aspect_ratio.num;
-			videoProperties->PixelAspectRatio->Denominator = avVideoCodecCtx->sample_aspect_ratio.den;
-		}
-
-		videoProperties->Properties->Insert(MF_MT_INTERLACE_MODE, (uint32)_MFVideoInterlaceMode::MFVideoInterlace_MixedInterlaceOrProgressive);
-	}
-	if (rotateVideo)
-	{
-		Platform::Guid MF_MT_VIDEO_ROTATION(0xC380465D, 0x2271, 0x428C, 0x9B, 0x83, 0xEC, 0xEA, 0x3B, 0x4A, 0x85, 0xC1);
-		videoProperties->Properties->Insert(MF_MT_VIDEO_ROTATION, (uint32)rotationAngle);
-	}
-	// Detect the correct framerate
-	if (avVideoCodecCtx->framerate.num != 0 || avVideoCodecCtx->framerate.den != 1)
-	{
-		videoProperties->FrameRate->Numerator = avVideoCodecCtx->framerate.num;
-		videoProperties->FrameRate->Denominator = avVideoCodecCtx->framerate.den;
-	}
-	else if (avFormatCtx->streams[videoStreamIndex]->avg_frame_rate.num != 0 || avFormatCtx->streams[videoStreamIndex]->avg_frame_rate.den != 0)
-	{
-		videoProperties->FrameRate->Numerator = avFormatCtx->streams[videoStreamIndex]->avg_frame_rate.num;
-		videoProperties->FrameRate->Denominator = avFormatCtx->streams[videoStreamIndex]->avg_frame_rate.den;
-	}
-
-	videoProperties->Bitrate = (unsigned int)avVideoCodecCtx->bit_rate;
-	videoStreamDescriptor = ref new VideoStreamDescriptor(videoProperties);
-
-	return (videoStreamDescriptor != nullptr && videoSampleProvider != nullptr) ? S_OK : E_OUTOFMEMORY;
-}
-
-HRESULT FFmpegInteropMSS::ParseOptions(PropertySet^ ffmpegOptions)
-{
-	HRESULT hr = S_OK;
-
-	// Convert FFmpeg options given in PropertySet to AVDictionary. List of options can be found in https://www.ffmpeg.org/ffmpeg-protocols.html
-	if (ffmpegOptions != nullptr)
-	{
-		auto options = ffmpegOptions->First();
-
-		while (options->HasCurrent)
-		{
-			String^ key = options->Current->Key;
-			std::wstring keyW(key->Begin());
-			std::string keyA(keyW.begin(), keyW.end());
-			const char* keyChar = keyA.c_str();
-
-			// Convert value from Object^ to const char*. avformat_open_input will internally convert value from const char* to the correct type
-			String^ value = options->Current->Value->ToString();
-			std::wstring valueW(value->Begin());
-			std::string valueA(valueW.begin(), valueW.end());
-			const char* valueChar = valueA.c_str();
-
-			// Add key and value pair entry
-			if (av_dict_set(&avDict, keyChar, valueChar, 0) < 0)
-			{
-				hr = E_INVALIDARG;
-				break;
-			}
-
-			options->MoveNext();
-		}
-	}
-
-	return hr;
-}
-
-void FFmpegInteropMSS::OnStarting(MediaStreamSource ^sender, MediaStreamSourceStartingEventArgs ^args)
-{
-	MediaStreamSourceStartingRequest^ request = args->Request;
-
-	// Perform seek operation when MediaStreamSource received seek event from MediaElement
-	if (request->StartPosition && request->StartPosition->Value.Duration <= mediaDuration.Duration)
-	{
-		// Select the first valid stream either from video or audio
-		int streamIndex = videoStreamIndex >= 0 ? videoStreamIndex : audioStreamIndex >= 0 ? audioStreamIndex : -1;
-
-		if (streamIndex >= 0)
-		{
-			// Convert TimeSpan unit to AV_TIME_BASE
-			int64_t seekTarget = static_cast<int64_t>(request->StartPosition->Value.Duration / (av_q2d(avFormatCtx->streams[streamIndex]->time_base) * 10000000));
-
-			if (av_seek_frame(avFormatCtx, streamIndex, seekTarget, AVSEEK_FLAG_BACKWARD) < 0)
-			{
-				DebugMessage(L" - ### Error while seeking\n");
-			}
-			else
-			{
-				// Add deferral
-
-				// Flush the AudioSampleProvider
-				if (audioSampleProvider != nullptr)
-				{
-					audioSampleProvider->Flush();
-					avcodec_flush_buffers(avAudioCodecCtx);
-				}
-
-				// Flush the VideoSampleProvider
-				if (videoSampleProvider != nullptr)
-				{
-					videoSampleProvider->Flush();
-					avcodec_flush_buffers(avVideoCodecCtx);
-				}
-			}
-		}
-
-		request->SetActualStartPosition(request->StartPosition->Value);
-	}
-}
-
-void FFmpegInteropMSS::OnSampleRequested(Windows::Media::Core::MediaStreamSource ^sender, MediaStreamSourceSampleRequestedEventArgs ^args)
-{
-	mutexGuard.lock();
-	if (mss != nullptr)
-	{
-		if (args->Request->StreamDescriptor == audioStreamDescriptor && audioSampleProvider != nullptr)
-		{
-			args->Request->Sample = audioSampleProvider->GetNextSample();
-		}
-		else if (args->Request->StreamDescriptor == videoStreamDescriptor && videoSampleProvider != nullptr)
-		{
-			args->Request->Sample = videoSampleProvider->GetNextSample();
-		}
-		else
-		{
-			args->Request->Sample = nullptr;
-		}
-	}
-	mutexGuard.unlock();
-}
-
-// Static function to read file stream and pass data to FFmpeg. Credit to Philipp Sch http://www.codeproject.com/Tips/489450/Creating-Custom-FFmpeg-IO-Context
-static int FileStreamRead(void* ptr, uint8_t* buf, int bufSize)
-{
-	IStream* pStream = reinterpret_cast<IStream*>(ptr);
-	ULONG bytesRead = 0;
-	HRESULT hr = pStream->Read(buf, bufSize, &bytesRead);
-
-	if (FAILED(hr))
-	{
-		return -1;
-	}
-
-	// If we succeed but don't have any bytes, assume end of file
-	if (bytesRead == 0)
-	{
-		return AVERROR_EOF;  // Let FFmpeg know that we have reached eof
-	}
-
-	return bytesRead;
-}
-
-// Static function to seek in file stream. Credit to Philipp Sch http://www.codeproject.com/Tips/489450/Creating-Custom-FFmpeg-IO-Context
-static int64_t FileStreamSeek(void* ptr, int64_t pos, int whence)
-{
-	IStream* pStream = reinterpret_cast<IStream*>(ptr);
-	LARGE_INTEGER in;
-	in.QuadPart = pos;
-	ULARGE_INTEGER out = { 0 };
-
-	if (FAILED(pStream->Seek(in, whence, &out)))
-	{
-		return -1;
-	}
-
-	return out.QuadPart; // Return the new position:
-}
+HRESULT FFmpegInteropMSS::InitFFmpegContext(bool forceAudioDecode, bool forceVideoDecode)
+{
+	HRESULT hr = S_OK;
+
+	if (SUCCEEDED(hr))
+	{
+		if (avformat_find_stream_info(avFormatCtx, NULL) < 0)
+		{
+			hr = E_FAIL; // Error finding info
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		m_pReader = ref new FFmpegReader(avFormatCtx);
+		if (m_pReader == nullptr)
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Find the audio stream and its decoder
+		AVCodec* avAudioCodec = nullptr;
+		audioStreamIndex = av_find_best_stream(avFormatCtx, AVMEDIA_TYPE_AUDIO, -1, -1, &avAudioCodec, 0);
+		if (audioStreamIndex != AVERROR_STREAM_NOT_FOUND && avAudioCodec)
+		{
+			// allocate a new decoding context
+			avAudioCodecCtx = avcodec_alloc_context3(avAudioCodec);
+			if (!avAudioCodecCtx)
+			{
+				hr = E_OUTOFMEMORY;
+				DebugMessage(L"Could not allocate a decoding context\n");
+				avformat_close_input(&avFormatCtx);
+			}
+
+			if (SUCCEEDED(hr))
+			{
+				// initialize the stream parameters with demuxer information
+				if (avcodec_parameters_to_context(avAudioCodecCtx, avFormatCtx->streams[audioStreamIndex]->codecpar) < 0)
+				{
+					hr = E_FAIL;
+					avformat_close_input(&avFormatCtx);
+					avcodec_free_context(&avAudioCodecCtx);
+				}
+
+				if (SUCCEEDED(hr))
+				{
+					if (avcodec_open2(avAudioCodecCtx, avAudioCodec, NULL) < 0)
+					{
+						avAudioCodecCtx = nullptr;
+						hr = E_FAIL;
+					}
+					else
+					{
+						// Detect audio format and create audio stream descriptor accordingly
+						hr = CreateAudioStreamDescriptor(forceAudioDecode);
+						if (SUCCEEDED(hr))
+						{
+							hr = audioSampleProvider->AllocateResources();
+							if (SUCCEEDED(hr))
+							{
+								m_pReader->SetAudioStream(audioStreamIndex, audioSampleProvider);
+							}
+						}
+
+						if (SUCCEEDED(hr))
+						{
+							// Convert audio codec name for property
+							hr = ConvertCodecName(avAudioCodec->name, &audioCodecName);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Find the video stream and its decoder
+		AVCodec* avVideoCodec = nullptr;
+		videoStreamIndex = av_find_best_stream(avFormatCtx, AVMEDIA_TYPE_VIDEO, -1, -1, &avVideoCodec, 0);
+		if (videoStreamIndex != AVERROR_STREAM_NOT_FOUND && avVideoCodec)
+		{
+			// FFmpeg identifies album/cover art from a music file as a video stream
+			// Avoid creating unnecessarily video stream from this album/cover art
+			if (avFormatCtx->streams[videoStreamIndex]->disposition == AV_DISPOSITION_ATTACHED_PIC)
+			{
+				thumbnailStreamIndex = videoStreamIndex;
+				videoStreamIndex = AVERROR_STREAM_NOT_FOUND;
+				avVideoCodec = nullptr;
+			}
+			else
+			{
+				thumbnailStreamIndex = AVERROR_STREAM_NOT_FOUND;
+				AVDictionaryEntry *rotate_tag = av_dict_get(avFormatCtx->streams[videoStreamIndex]->metadata, "rotate", NULL, 0);
+				if (rotate_tag != NULL)
+				{
+					rotateVideo = true;
+					rotationAngle = atoi(rotate_tag->value);
+				}
+				else
+				{
+					rotateVideo = false;
+				}
+				// allocate a new decoding context
+				avVideoCodecCtx = avcodec_alloc_context3(avVideoCodec);
+				if (!avVideoCodecCtx)
+				{
+					DebugMessage(L"Could not allocate a decoding context\n");
+					avformat_close_input(&avFormatCtx);
+					hr = E_OUTOFMEMORY;
+				}
+
+				if (SUCCEEDED(hr))
+				{
+					// initialize the stream parameters with demuxer information
+					if (avcodec_parameters_to_context(avVideoCodecCtx, avFormatCtx->streams[videoStreamIndex]->codecpar) < 0)
+					{
+						avformat_close_input(&avFormatCtx);
+						avcodec_free_context(&avVideoCodecCtx);
+						hr = E_FAIL;
+					}
+				}
+
+				if (SUCCEEDED(hr))
+				{
+					if (avcodec_open2(avVideoCodecCtx, avVideoCodec, NULL) < 0)
+					{
+						avVideoCodecCtx = nullptr;
+						hr = E_FAIL; // Cannot open the video codec
+					}
+					else
+					{
+						// Detect video format and create video stream descriptor accordingly
+						hr = CreateVideoStreamDescriptor(forceVideoDecode);
+						if (SUCCEEDED(hr))
+						{
+							hr = videoSampleProvider->AllocateResources();
+							if (SUCCEEDED(hr))
+							{
+								m_pReader->SetVideoStream(videoStreamIndex, videoSampleProvider);
+							}
+						}
+
+						if (SUCCEEDED(hr))
+						{
+							// Convert video codec name for property
+							hr = ConvertCodecName(avVideoCodec->name, &videoCodecName);
+						}
+					}
+				}
+			}
+		}
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		// Convert media duration from AV_TIME_BASE to TimeSpan unit
+		mediaDuration = { LONGLONG(avFormatCtx->duration * 10000000 / double(AV_TIME_BASE)) };
+
+		if (audioStreamDescriptor)
+		{
+			if (videoStreamDescriptor)
+			{
+				if (mss)
+				{
+					mss->AddStreamDescriptor(videoStreamDescriptor);
+					mss->AddStreamDescriptor(audioStreamDescriptor);
+				}
+				else
+				{
+					mss = ref new MediaStreamSource(videoStreamDescriptor, audioStreamDescriptor);
+				}
+			}
+			else
+			{
+				if (mss)
+				{
+					mss->AddStreamDescriptor(audioStreamDescriptor);
+				}
+				else
+				{
+					mss = ref new MediaStreamSource(audioStreamDescriptor);
+				}
+			}
+		}
+		else if (videoStreamDescriptor)
+		{
+			if (mss)
+			{
+				mss->AddStreamDescriptor(videoStreamDescriptor);
+			}
+			else
+			{
+				mss = ref new MediaStreamSource(videoStreamDescriptor);
+			}
+		}
+		if (mss)
+		{
+			if (mediaDuration.Duration > 0)
+			{
+				mss->Duration = mediaDuration;
+				mss->CanSeek = true;
+			}
+			else
+			{
+				// Set buffer time to 0 for realtime streaming to reduce latency
+				mss->BufferTime = { 0 };
+			}
+
+			startingRequestedToken = mss->Starting += ref new TypedEventHandler<MediaStreamSource ^, MediaStreamSourceStartingEventArgs ^>(this, &FFmpegInteropMSS::OnStarting);
+			sampleRequestedToken = mss->SampleRequested += ref new TypedEventHandler<MediaStreamSource ^, MediaStreamSourceSampleRequestedEventArgs ^>(this, &FFmpegInteropMSS::OnSampleRequested);
+		}
+		else
+		{
+			hr = E_OUTOFMEMORY;
+		}
+	}
+
+	return hr;
+}
+
+MediaThumbnailData ^ FFmpegInterop::FFmpegInteropMSS::ExtractThumbnail()
+{
+	if (thumbnailStreamIndex != AVERROR_STREAM_NOT_FOUND)
+	{
+		// FFmpeg identifies album/cover art from a music file as a video stream
+		// Avoid creating unnecessarily video stream from this album/cover art
+		if (avFormatCtx->streams[thumbnailStreamIndex]->disposition == AV_DISPOSITION_ATTACHED_PIC)
+		{
+			auto imageStream = avFormatCtx->streams[thumbnailStreamIndex];
+			//save album art to file.
+			String^ extension = ".jpeg";
+			switch (imageStream->codecpar->codec_id)
+			{
+			case AV_CODEC_ID_MJPEG:
+			case AV_CODEC_ID_MJPEGB:
+			case AV_CODEC_ID_JPEG2000:
+			case AV_CODEC_ID_JPEGLS: extension = ".jpeg"; break;
+			case AV_CODEC_ID_PNG: extension = ".png"; break;
+			case AV_CODEC_ID_BMP: extension = ".bmp"; break;
+			}
+
+
+			auto vector = ref new Array<uint8_t>(imageStream->attached_pic.data, imageStream->attached_pic.size);
+			DataWriter^ writer = ref new DataWriter();
+			writer->WriteBytes(vector);
+
+			return (ref new MediaThumbnailData(writer->DetachBuffer(), extension));
+		}
+	}
+
+	return nullptr;
+}
+
+HRESULT FFmpegInteropMSS::ConvertCodecName(const char* codecName, String^ *outputCodecName)
+{
+	HRESULT hr = S_OK;
+
+	// Convert codec name from const char* to Platform::String
+	auto codecNameChars = codecName;
+	size_t newsize = strlen(codecNameChars) + 1;
+	wchar_t * wcstring = new(std::nothrow) wchar_t[newsize];
+	if (wcstring == nullptr)
+	{
+		hr = E_OUTOFMEMORY;
+	}
+
+	if (SUCCEEDED(hr))
+	{
+		size_t convertedChars = 0;
+		mbstowcs_s(&convertedChars, wcstring, newsize, codecNameChars, _TRUNCATE);
+		*outputCodecName = ref new Platform::String(wcstring);
+		delete[] wcstring;
+	}
+
+	return hr;
+}
+
+HRESULT FFmpegInteropMSS::CreateAudioStreamDescriptor(bool forceAudioDecode)
+{
+	if (avAudioCodecCtx->codec_id == AV_CODEC_ID_AAC && !forceAudioDecode)
+	{
+		if (avAudioCodecCtx->extradata_size == 0)
+		{
+			audioStreamDescriptor = ref new AudioStreamDescriptor(AudioEncodingProperties::CreateAacAdts(avAudioCodecCtx->sample_rate, avAudioCodecCtx->channels, (unsigned int)avAudioCodecCtx->bit_rate));
+		}
+		else
+		{
+			audioStreamDescriptor = ref new AudioStreamDescriptor(AudioEncodingProperties::CreateAac(avAudioCodecCtx->sample_rate, avAudioCodecCtx->channels, (unsigned int)avAudioCodecCtx->bit_rate));
+		}
+		audioSampleProvider = ref new MediaSampleProvider(m_pReader, avFormatCtx, avAudioCodecCtx);
+	}
+	else if (avAudioCodecCtx->codec_id == AV_CODEC_ID_MP3 && !forceAudioDecode)
+	{
+		audioStreamDescriptor = ref new AudioStreamDescriptor(AudioEncodingProperties::CreateMp3(avAudioCodecCtx->sample_rate, avAudioCodecCtx->channels, (unsigned int)avAudioCodecCtx->bit_rate));
+		audioSampleProvider = ref new MediaSampleProvider(m_pReader, avFormatCtx, avAudioCodecCtx);
+	}
+	else
+	{
+		// We always convert to 16-bit audio so set the size here
+		audioStreamDescriptor = ref new AudioStreamDescriptor(AudioEncodingProperties::CreatePcm(avAudioCodecCtx->sample_rate, avAudioCodecCtx->channels, 16));
+		audioSampleProvider = ref new UncompressedAudioSampleProvider(m_pReader, avFormatCtx, avAudioCodecCtx);
+	}
+
+	return (audioStreamDescriptor != nullptr && audioSampleProvider != nullptr) ? S_OK : E_OUTOFMEMORY;
+}
+
+HRESULT FFmpegInteropMSS::CreateVideoStreamDescriptor(bool forceVideoDecode)
+{
+	VideoEncodingProperties^ videoProperties;
+
+	if (avVideoCodecCtx->codec_id == AV_CODEC_ID_H264 && !forceVideoDecode)
+	{
+		videoProperties = VideoEncodingProperties::CreateH264();
+		videoProperties->ProfileId = avVideoCodecCtx->profile;
+		videoProperties->Height = avVideoCodecCtx->height;
+		videoProperties->Width = avVideoCodecCtx->width;
+
+		// Check for H264 bitstream flavor. H.264 AVC extradata starts with 1 while non AVC one starts with 0
+		if (avVideoCodecCtx->extradata != nullptr && avVideoCodecCtx->extradata_size > 0 && avVideoCodecCtx->extradata[0] == 1)
+		{
+			videoSampleProvider = ref new H264AVCSampleProvider(m_pReader, avFormatCtx, avVideoCodecCtx);
+		}
+		else
+		{
+			videoSampleProvider = ref new H264SampleProvider(m_pReader, avFormatCtx, avVideoCodecCtx);
+		}
+	}
+	else
+	{
+		videoProperties = VideoEncodingProperties::CreateUncompressed(MediaEncodingSubtypes::Nv12, avVideoCodecCtx->width, avVideoCodecCtx->height);
+		videoSampleProvider = ref new UncompressedVideoSampleProvider(m_pReader, avFormatCtx, avVideoCodecCtx);
+
+		if (avVideoCodecCtx->sample_aspect_ratio.num > 0 && avVideoCodecCtx->sample_aspect_ratio.den != 0)
+		{
+			videoProperties->PixelAspectRatio->Numerator = avVideoCodecCtx->sample_aspect_ratio.num;
+			videoProperties->PixelAspectRatio->Denominator = avVideoCodecCtx->sample_aspect_ratio.den;
+		}
+
+		videoProperties->Properties->Insert(MF_MT_INTERLACE_MODE, (uint32)_MFVideoInterlaceMode::MFVideoInterlace_MixedInterlaceOrProgressive);
+	}
+	if (rotateVideo)
+	{
+		Platform::Guid MF_MT_VIDEO_ROTATION(0xC380465D, 0x2271, 0x428C, 0x9B, 0x83, 0xEC, 0xEA, 0x3B, 0x4A, 0x85, 0xC1);
+		videoProperties->Properties->Insert(MF_MT_VIDEO_ROTATION, (uint32)rotationAngle);
+	}
+	// Detect the correct framerate
+	if (avVideoCodecCtx->framerate.num != 0 || avVideoCodecCtx->framerate.den != 1)
+	{
+		videoProperties->FrameRate->Numerator = avVideoCodecCtx->framerate.num;
+		videoProperties->FrameRate->Denominator = avVideoCodecCtx->framerate.den;
+	}
+	else if (avFormatCtx->streams[videoStreamIndex]->avg_frame_rate.num != 0 || avFormatCtx->streams[videoStreamIndex]->avg_frame_rate.den != 0)
+	{
+		videoProperties->FrameRate->Numerator = avFormatCtx->streams[videoStreamIndex]->avg_frame_rate.num;
+		videoProperties->FrameRate->Denominator = avFormatCtx->streams[videoStreamIndex]->avg_frame_rate.den;
+	}
+
+	videoProperties->Bitrate = (unsigned int)avVideoCodecCtx->bit_rate;
+	videoStreamDescriptor = ref new VideoStreamDescriptor(videoProperties);
+
+	return (videoStreamDescriptor != nullptr && videoSampleProvider != nullptr) ? S_OK : E_OUTOFMEMORY;
+}
+
+HRESULT FFmpegInteropMSS::ParseOptions(PropertySet^ ffmpegOptions)
+{
+	HRESULT hr = S_OK;
+
+	// Convert FFmpeg options given in PropertySet to AVDictionary. List of options can be found in https://www.ffmpeg.org/ffmpeg-protocols.html
+	if (ffmpegOptions != nullptr)
+	{
+		auto options = ffmpegOptions->First();
+
+		while (options->HasCurrent)
+		{
+			String^ key = options->Current->Key;
+			std::wstring keyW(key->Begin());
+			std::string keyA(keyW.begin(), keyW.end());
+			const char* keyChar = keyA.c_str();
+
+			// Convert value from Object^ to const char*. avformat_open_input will internally convert value from const char* to the correct type
+			String^ value = options->Current->Value->ToString();
+			std::wstring valueW(value->Begin());
+			std::string valueA(valueW.begin(), valueW.end());
+			const char* valueChar = valueA.c_str();
+
+			// Add key and value pair entry
+			if (av_dict_set(&avDict, keyChar, valueChar, 0) < 0)
+			{
+				hr = E_INVALIDARG;
+				break;
+			}
+
+			options->MoveNext();
+		}
+	}
+
+	return hr;
+}
+
+void FFmpegInteropMSS::OnStarting(MediaStreamSource ^sender, MediaStreamSourceStartingEventArgs ^args)
+{
+	MediaStreamSourceStartingRequest^ request = args->Request;
+	DebugMessage(L"OnStarting\n");
+
+	// Perform seek operation when MediaStreamSource received seek event from MediaElement
+	if (request->StartPosition && request->StartPosition->Value.Duration <= mediaDuration.Duration)
+	{
+		// Select the first valid stream either from video or audio
+		int streamIndex = videoStreamIndex >= 0 ? videoStreamIndex : audioStreamIndex >= 0 ? audioStreamIndex : -1;
+
+		if (streamIndex >= 0)
+		{
+			// Convert TimeSpan unit to AV_TIME_BASE
+			int64_t seekTarget = static_cast<int64_t>(request->StartPosition->Value.Duration / (av_q2d(avFormatCtx->streams[streamIndex]->time_base) * 10000000));
+
+			if (av_seek_frame(avFormatCtx, streamIndex, seekTarget, AVSEEK_FLAG_BACKWARD) < 0)
+			{
+				DebugMessage(L" - ### Error while seeking\n");
+			}
+			else
+			{
+				// Add deferral
+
+				// Flush the AudioSampleProvider
+				if (audioSampleProvider != nullptr)
+				{
+					audioSampleProvider->Flush();
+					avcodec_flush_buffers(avAudioCodecCtx);
+				}
+
+				// Flush the VideoSampleProvider
+				if (videoSampleProvider != nullptr)
+				{
+					videoSampleProvider->Flush();
+					avcodec_flush_buffers(avVideoCodecCtx);
+				}
+			}
+		}
+
+		request->SetActualStartPosition(request->StartPosition->Value);
+	}
+}
+
+void FFmpegInteropMSS::OnSampleRequested(Windows::Media::Core::MediaStreamSource ^sender, MediaStreamSourceSampleRequestedEventArgs ^args)
+{
+	DebugMessage(L"OnSampleRequested\n");
+	mutexGuard.lock();
+	if (mss != nullptr)
+	{
+		if (args->Request->StreamDescriptor == audioStreamDescriptor && audioSampleProvider != nullptr)
+		{
+			args->Request->Sample = audioSampleProvider->GetNextSample();
+		}
+		else if (args->Request->StreamDescriptor == videoStreamDescriptor && videoSampleProvider != nullptr)
+		{
+			args->Request->Sample = videoSampleProvider->GetNextSample();
+		}
+		else
+		{
+			args->Request->Sample = nullptr;
+		}
+	}
+	mutexGuard.unlock();
+}
+
+// Static function to read file stream and pass data to FFmpeg. Credit to Philipp Sch http://www.codeproject.com/Tips/489450/Creating-Custom-FFmpeg-IO-Context
+static int FileStreamRead(void* ptr, uint8_t* buf, int bufSize)
+{
+	IStream* pStream = reinterpret_cast<IStream*>(ptr);
+	ULONG bytesRead = 0;
+	HRESULT hr = pStream->Read(buf, bufSize, &bytesRead);
+
+	if (FAILED(hr))
+	{
+		return -1;
+	}
+
+	// If we succeed but don't have any bytes, assume end of file
+	if (bytesRead == 0)
+	{
+		return AVERROR_EOF;  // Let FFmpeg know that we have reached eof
+	}
+
+	return bytesRead;
+}
+
+// Static function to seek in file stream. Credit to Philipp Sch http://www.codeproject.com/Tips/489450/Creating-Custom-FFmpeg-IO-Context
+static int64_t FileStreamSeek(void* ptr, int64_t pos, int whence)
+{
+	IStream* pStream = reinterpret_cast<IStream*>(ptr);
+	LARGE_INTEGER in;
+	in.QuadPart = pos;
+	ULARGE_INTEGER out = { 0 };
+
+	if (FAILED(pStream->Seek(in, whence, &out)))
+	{
+		return -1;
+	}
+
+	return out.QuadPart; // Return the new position:
+}
diff --git a/FFmpegInterop/Source/FFmpegInteropMSS.h b/FFmpegInterop/Source/FFmpegInteropMSS.h
index 10d45a0..8598942 100644
--- a/FFmpegInterop/Source/FFmpegInteropMSS.h
+++ b/FFmpegInterop/Source/FFmpegInteropMSS.h
@@ -27,6 +27,7 @@ using namespace Platform;
 using namespace Windows::Foundation;
 using namespace Windows::Foundation::Collections;
 using namespace Windows::Media::Core;
+//using namespace System::IO;
 
 extern "C"
 {
@@ -41,6 +42,9 @@ namespace FFmpegInterop
 		static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromStream(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss);
 		static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromStream(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions);
 		static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromStream(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode);
+
+		// static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromStream(IStream* stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss);
+
 		static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromUri(String^ uri, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions);
 		static FFmpegInteropMSS^ CreateFFmpegInteropMSSFromUri(String^ uri, bool forceAudioDecode, bool forceVideoDecode);
 		MediaThumbnailData^ ExtractThumbnail();
@@ -92,6 +96,8 @@ namespace FFmpegInterop
 	private:
 		FFmpegInteropMSS();
 
+		HRESULT CreateMediaStreamSource(IStream* stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss);
+
 		HRESULT CreateMediaStreamSource(IRandomAccessStream^ stream, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions, MediaStreamSource^ mss);
 		HRESULT CreateMediaStreamSource(String^ uri, bool forceAudioDecode, bool forceVideoDecode, PropertySet^ ffmpegOptions);
 		HRESULT InitFFmpegContext(bool forceAudioDecode, bool forceVideoDecode);
diff --git a/FFmpegWin10.sln b/FFmpegWin10.sln
index 5065c50..c99ee68 100644
--- a/FFmpegWin10.sln
+++ b/FFmpegWin10.sln
@@ -1,7 +1,7 @@
 ﻿
 Microsoft Visual Studio Solution File, Format Version 12.00
 # Visual Studio 14
-VisualStudioVersion = 14.0.23107.0
+VisualStudioVersion = 14.0.25420.1
 MinimumVisualStudioVersion = 10.0.40219.1
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FFmpegInterop", "FFmpegInterop\Win10\FFmpegInterop\FFmpegInterop.vcxproj", "{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}"
 EndProject
@@ -13,16 +13,25 @@ Project("{262852C6-CD72-467D-83FE-5EEB1973A190}") = "MediaPlayerJS", "Samples\Sa
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "UnitTest", "Tests\Win10\UnitTest\UnitTest.csproj", "{F1ECBD62-71FE-47FB-B588-1E331A375B59}"
 EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "CLR", "CLR", "{DB03B01D-80D8-439E-9316-69389E0D543E}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FFmpegInterop.CLR", "FFmpegInterop\CLR\FFmpegInterop.CLR\FFmpegInterop.CLR.vcxproj", "{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TestConsole", "TestConsole\TestConsole.csproj", "{D6661831-88B6-4F09-9A3D-563AD44EF098}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Any CPU = Debug|Any CPU
 		Debug|ARM = Debug|ARM
 		Debug|x64 = Debug|x64
 		Debug|x86 = Debug|x86
+		Release|Any CPU = Release|Any CPU
 		Release|ARM = Release|ARM
 		Release|x64 = Release|x64
 		Release|x86 = Release|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Debug|Any CPU.ActiveCfg = Debug|Win32
 		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Debug|ARM.ActiveCfg = Debug|ARM
 		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Debug|ARM.Build.0 = Debug|ARM
 		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Debug|x64.ActiveCfg = Debug|x64
@@ -30,12 +39,14 @@ Global
 		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Debug|x86.ActiveCfg = Debug|Win32
 		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Debug|x86.Build.0 = Debug|Win32
 		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Debug|x86.Deploy.0 = Debug|Win32
+		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Release|Any CPU.ActiveCfg = Release|Win32
 		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Release|ARM.ActiveCfg = Release|ARM
 		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Release|ARM.Build.0 = Release|ARM
 		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Release|x64.ActiveCfg = Release|x64
 		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Release|x64.Build.0 = Release|x64
 		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Release|x86.ActiveCfg = Release|Win32
 		{9CFA3B3E-B7AF-4629-84E2-C962C5B046B1}.Release|x86.Build.0 = Release|Win32
+		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Debug|Any CPU.ActiveCfg = Debug|Win32
 		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Debug|ARM.ActiveCfg = Debug|ARM
 		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Debug|ARM.Build.0 = Debug|ARM
 		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Debug|ARM.Deploy.0 = Debug|ARM
@@ -45,6 +56,7 @@ Global
 		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Debug|x86.ActiveCfg = Debug|Win32
 		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Debug|x86.Build.0 = Debug|Win32
 		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Debug|x86.Deploy.0 = Debug|Win32
+		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Release|Any CPU.ActiveCfg = Release|Win32
 		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Release|ARM.ActiveCfg = Release|ARM
 		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Release|ARM.Build.0 = Release|ARM
 		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Release|ARM.Deploy.0 = Release|ARM
@@ -54,6 +66,7 @@ Global
 		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Release|x86.ActiveCfg = Release|Win32
 		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Release|x86.Build.0 = Release|Win32
 		{9C0EB7EC-6FED-46E7-9CC9-F36132050AA1}.Release|x86.Deploy.0 = Release|Win32
+		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Debug|Any CPU.ActiveCfg = Debug|x86
 		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Debug|ARM.ActiveCfg = Debug|ARM
 		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Debug|ARM.Build.0 = Debug|ARM
 		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Debug|ARM.Deploy.0 = Debug|ARM
@@ -63,6 +76,7 @@ Global
 		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Debug|x86.ActiveCfg = Debug|x86
 		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Debug|x86.Build.0 = Debug|x86
 		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Debug|x86.Deploy.0 = Debug|x86
+		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Release|Any CPU.ActiveCfg = Release|x86
 		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Release|ARM.ActiveCfg = Release|ARM
 		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Release|ARM.Build.0 = Release|ARM
 		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Release|ARM.Deploy.0 = Release|ARM
@@ -72,6 +86,7 @@ Global
 		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Release|x86.ActiveCfg = Release|x86
 		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Release|x86.Build.0 = Release|x86
 		{3CFE9DE0-525A-474E-A7F3-876CC2876CFB}.Release|x86.Deploy.0 = Release|x86
+		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Debug|Any CPU.ActiveCfg = Debug|x86
 		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Debug|ARM.ActiveCfg = Debug|ARM
 		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Debug|ARM.Build.0 = Debug|ARM
 		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Debug|ARM.Deploy.0 = Debug|ARM
@@ -81,6 +96,7 @@ Global
 		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Debug|x86.ActiveCfg = Debug|x86
 		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Debug|x86.Build.0 = Debug|x86
 		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Debug|x86.Deploy.0 = Debug|x86
+		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Release|Any CPU.ActiveCfg = Release|x86
 		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Release|ARM.ActiveCfg = Release|ARM
 		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Release|ARM.Build.0 = Release|ARM
 		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Release|ARM.Deploy.0 = Release|ARM
@@ -90,6 +106,7 @@ Global
 		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Release|x86.ActiveCfg = Release|x86
 		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Release|x86.Build.0 = Release|x86
 		{C09EF0AC-5F4D-4207-B4C2-77658A9E5365}.Release|x86.Deploy.0 = Release|x86
+		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Debug|Any CPU.ActiveCfg = Debug|x86
 		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Debug|ARM.ActiveCfg = Debug|ARM
 		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Debug|ARM.Build.0 = Debug|ARM
 		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Debug|ARM.Deploy.0 = Debug|ARM
@@ -99,6 +116,7 @@ Global
 		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Debug|x86.ActiveCfg = Debug|x86
 		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Debug|x86.Build.0 = Debug|x86
 		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Debug|x86.Deploy.0 = Debug|x86
+		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Release|Any CPU.ActiveCfg = Release|x86
 		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Release|ARM.ActiveCfg = Release|ARM
 		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Release|ARM.Build.0 = Release|ARM
 		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Release|ARM.Deploy.0 = Release|ARM
@@ -108,8 +126,40 @@ Global
 		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Release|x86.ActiveCfg = Release|x86
 		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Release|x86.Build.0 = Release|x86
 		{F1ECBD62-71FE-47FB-B588-1E331A375B59}.Release|x86.Deploy.0 = Release|x86
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Debug|Any CPU.ActiveCfg = Debug|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Debug|ARM.ActiveCfg = Debug|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Debug|x64.ActiveCfg = Debug|x64
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Debug|x64.Build.0 = Debug|x64
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Debug|x86.ActiveCfg = Debug|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Debug|x86.Build.0 = Debug|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Release|Any CPU.ActiveCfg = Release|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Release|ARM.ActiveCfg = Release|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Release|x64.ActiveCfg = Release|x64
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Release|x64.Build.0 = Release|x64
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Release|x86.ActiveCfg = Release|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Release|x86.Build.0 = Release|Win32
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Debug|ARM.ActiveCfg = Debug|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Debug|ARM.Build.0 = Debug|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Debug|x64.ActiveCfg = Debug|x64
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Debug|x64.Build.0 = Debug|x64
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Debug|x86.ActiveCfg = Debug|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Debug|x86.Build.0 = Debug|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Release|Any CPU.Build.0 = Release|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Release|ARM.ActiveCfg = Release|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Release|ARM.Build.0 = Release|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Release|x64.ActiveCfg = Release|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Release|x64.Build.0 = Release|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Release|x86.ActiveCfg = Release|Any CPU
+		{D6661831-88B6-4F09-9A3D-563AD44EF098}.Release|x86.Build.0 = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
 	EndGlobalSection
+	GlobalSection(NestedProjects) = preSolution
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3} = {DB03B01D-80D8-439E-9316-69389E0D543E}
+		{D6661831-88B6-4F09-9A3D-563AD44EF098} = {DB03B01D-80D8-439E-9316-69389E0D543E}
+	EndGlobalSection
 EndGlobal
diff --git a/FFmpegWin8.1.sln b/FFmpegWin8.1.sln
index 88bc8bc..11f9624 100644
--- a/FFmpegWin8.1.sln
+++ b/FFmpegWin8.1.sln
@@ -1,7 +1,7 @@
 ﻿
 Microsoft Visual Studio Solution File, Format Version 12.00
 # Visual Studio 2013
-VisualStudioVersion = 12.0.31101.0
+VisualStudioVersion = 12.0.40629.0
 MinimumVisualStudioVersion = 10.0.40219.1
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "FFmpegInterop", "FFmpegInterop", "{69A759E9-483B-4B19-813B-7F8D5B376F99}"
 EndProject
@@ -41,6 +41,10 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "UnitTest.Windows", "Tests\W
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "UnitTest.WindowsPhone", "Tests\Win8.1\UnitTest.WindowsPhone\UnitTest.WindowsPhone.csproj", "{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}"
 EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "CLR", "CLR", "{C69BA044-3BCD-42B4-8731-1A45AD15B31D}"
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "FFmpegInterop.CLR", "FFmpegInterop\CLR\FFmpegInterop.CLR\FFmpegInterop.CLR.vcxproj", "{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}"
+EndProject
 Global
 	GlobalSection(SharedMSBuildProjectFiles) = preSolution
 		FFmpegInterop\Win8.1\FFmpegInterop.Shared\FFmpegInterop.Shared.vcxitems*{b290d2ce-e857-4ace-8541-d80a3b9ab04e}*SharedItemsImports = 9
@@ -58,38 +62,51 @@ Global
 	EndGlobalSection
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|ARM = Debug|ARM
+		Debug|Mixed Platforms = Debug|Mixed Platforms
 		Debug|Win32 = Debug|Win32
 		Debug|x64 = Debug|x64
 		Release|ARM = Release|ARM
+		Release|Mixed Platforms = Release|Mixed Platforms
 		Release|Win32 = Release|Win32
 		Release|x64 = Release|x64
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
 		{97248E49-6262-4C37-B118-224FF3B98FD0}.Debug|ARM.ActiveCfg = Debug|ARM
 		{97248E49-6262-4C37-B118-224FF3B98FD0}.Debug|ARM.Build.0 = Debug|ARM
+		{97248E49-6262-4C37-B118-224FF3B98FD0}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
+		{97248E49-6262-4C37-B118-224FF3B98FD0}.Debug|Mixed Platforms.Build.0 = Debug|Win32
 		{97248E49-6262-4C37-B118-224FF3B98FD0}.Debug|Win32.ActiveCfg = Debug|Win32
 		{97248E49-6262-4C37-B118-224FF3B98FD0}.Debug|Win32.Build.0 = Debug|Win32
 		{97248E49-6262-4C37-B118-224FF3B98FD0}.Debug|x64.ActiveCfg = Debug|x64
 		{97248E49-6262-4C37-B118-224FF3B98FD0}.Debug|x64.Build.0 = Debug|x64
 		{97248E49-6262-4C37-B118-224FF3B98FD0}.Release|ARM.ActiveCfg = Release|ARM
 		{97248E49-6262-4C37-B118-224FF3B98FD0}.Release|ARM.Build.0 = Release|ARM
+		{97248E49-6262-4C37-B118-224FF3B98FD0}.Release|Mixed Platforms.ActiveCfg = Release|Win32
+		{97248E49-6262-4C37-B118-224FF3B98FD0}.Release|Mixed Platforms.Build.0 = Release|Win32
 		{97248E49-6262-4C37-B118-224FF3B98FD0}.Release|Win32.ActiveCfg = Release|Win32
 		{97248E49-6262-4C37-B118-224FF3B98FD0}.Release|Win32.Build.0 = Release|Win32
 		{97248E49-6262-4C37-B118-224FF3B98FD0}.Release|x64.ActiveCfg = Release|x64
 		{97248E49-6262-4C37-B118-224FF3B98FD0}.Release|x64.Build.0 = Release|x64
 		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Debug|ARM.ActiveCfg = Debug|ARM
 		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Debug|ARM.Build.0 = Debug|ARM
+		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
+		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Debug|Mixed Platforms.Build.0 = Debug|Win32
 		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Debug|Win32.ActiveCfg = Debug|Win32
 		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Debug|Win32.Build.0 = Debug|Win32
 		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Debug|x64.ActiveCfg = Debug|Win32
 		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Release|ARM.ActiveCfg = Release|ARM
 		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Release|ARM.Build.0 = Release|ARM
+		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Release|Mixed Platforms.ActiveCfg = Release|Win32
+		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Release|Mixed Platforms.Build.0 = Release|Win32
 		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Release|Win32.ActiveCfg = Release|Win32
 		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Release|Win32.Build.0 = Release|Win32
 		{EBC5CA98-87F1-4A01-A48D-69659C103E72}.Release|x64.ActiveCfg = Release|Win32
 		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Debug|ARM.ActiveCfg = Debug|ARM
 		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Debug|ARM.Build.0 = Debug|ARM
 		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Debug|ARM.Deploy.0 = Debug|ARM
+		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
+		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Debug|Mixed Platforms.Build.0 = Debug|Win32
+		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Debug|Mixed Platforms.Deploy.0 = Debug|Win32
 		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Debug|Win32.ActiveCfg = Debug|Win32
 		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Debug|Win32.Build.0 = Debug|Win32
 		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Debug|Win32.Deploy.0 = Debug|Win32
@@ -99,6 +116,9 @@ Global
 		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Release|ARM.ActiveCfg = Release|ARM
 		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Release|ARM.Build.0 = Release|ARM
 		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Release|ARM.Deploy.0 = Release|ARM
+		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Release|Mixed Platforms.ActiveCfg = Release|Win32
+		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Release|Mixed Platforms.Build.0 = Release|Win32
+		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Release|Mixed Platforms.Deploy.0 = Release|Win32
 		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Release|Win32.ActiveCfg = Release|Win32
 		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Release|Win32.Build.0 = Release|Win32
 		{CBB8BB5F-D071-4090-9AB8-7397FF4FB46E}.Release|Win32.Deploy.0 = Release|Win32
@@ -108,6 +128,9 @@ Global
 		{72DE715C-26E4-4774-A4C2-327B4F213008}.Debug|ARM.ActiveCfg = Debug|ARM
 		{72DE715C-26E4-4774-A4C2-327B4F213008}.Debug|ARM.Build.0 = Debug|ARM
 		{72DE715C-26E4-4774-A4C2-327B4F213008}.Debug|ARM.Deploy.0 = Debug|ARM
+		{72DE715C-26E4-4774-A4C2-327B4F213008}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
+		{72DE715C-26E4-4774-A4C2-327B4F213008}.Debug|Mixed Platforms.Build.0 = Debug|Win32
+		{72DE715C-26E4-4774-A4C2-327B4F213008}.Debug|Mixed Platforms.Deploy.0 = Debug|Win32
 		{72DE715C-26E4-4774-A4C2-327B4F213008}.Debug|Win32.ActiveCfg = Debug|Win32
 		{72DE715C-26E4-4774-A4C2-327B4F213008}.Debug|Win32.Build.0 = Debug|Win32
 		{72DE715C-26E4-4774-A4C2-327B4F213008}.Debug|Win32.Deploy.0 = Debug|Win32
@@ -115,6 +138,9 @@ Global
 		{72DE715C-26E4-4774-A4C2-327B4F213008}.Release|ARM.ActiveCfg = Release|ARM
 		{72DE715C-26E4-4774-A4C2-327B4F213008}.Release|ARM.Build.0 = Release|ARM
 		{72DE715C-26E4-4774-A4C2-327B4F213008}.Release|ARM.Deploy.0 = Release|ARM
+		{72DE715C-26E4-4774-A4C2-327B4F213008}.Release|Mixed Platforms.ActiveCfg = Release|Win32
+		{72DE715C-26E4-4774-A4C2-327B4F213008}.Release|Mixed Platforms.Build.0 = Release|Win32
+		{72DE715C-26E4-4774-A4C2-327B4F213008}.Release|Mixed Platforms.Deploy.0 = Release|Win32
 		{72DE715C-26E4-4774-A4C2-327B4F213008}.Release|Win32.ActiveCfg = Release|Win32
 		{72DE715C-26E4-4774-A4C2-327B4F213008}.Release|Win32.Build.0 = Release|Win32
 		{72DE715C-26E4-4774-A4C2-327B4F213008}.Release|Win32.Deploy.0 = Release|Win32
@@ -122,6 +148,9 @@ Global
 		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Debug|ARM.ActiveCfg = Debug|ARM
 		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Debug|ARM.Build.0 = Debug|ARM
 		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Debug|ARM.Deploy.0 = Debug|ARM
+		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Debug|Mixed Platforms.Deploy.0 = Debug|x86
 		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Debug|Win32.ActiveCfg = Debug|x86
 		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Debug|Win32.Build.0 = Debug|x86
 		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Debug|Win32.Deploy.0 = Debug|x86
@@ -131,6 +160,9 @@ Global
 		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Release|ARM.ActiveCfg = Release|ARM
 		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Release|ARM.Build.0 = Release|ARM
 		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Release|ARM.Deploy.0 = Release|ARM
+		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Release|Mixed Platforms.Build.0 = Release|x86
+		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Release|Mixed Platforms.Deploy.0 = Release|x86
 		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Release|Win32.ActiveCfg = Release|x86
 		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Release|Win32.Build.0 = Release|x86
 		{E87BB8D4-8AAB-47EA-9028-901B2E2C199A}.Release|Win32.Deploy.0 = Release|x86
@@ -140,6 +172,9 @@ Global
 		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Debug|ARM.ActiveCfg = Debug|ARM
 		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Debug|ARM.Build.0 = Debug|ARM
 		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Debug|ARM.Deploy.0 = Debug|ARM
+		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Debug|Mixed Platforms.Deploy.0 = Debug|x86
 		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Debug|Win32.ActiveCfg = Debug|x86
 		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Debug|Win32.Build.0 = Debug|x86
 		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Debug|Win32.Deploy.0 = Debug|x86
@@ -147,6 +182,9 @@ Global
 		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Release|ARM.ActiveCfg = Release|ARM
 		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Release|ARM.Build.0 = Release|ARM
 		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Release|ARM.Deploy.0 = Release|ARM
+		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Release|Mixed Platforms.Build.0 = Release|x86
+		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Release|Mixed Platforms.Deploy.0 = Release|x86
 		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Release|Win32.ActiveCfg = Release|x86
 		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Release|Win32.Build.0 = Release|x86
 		{2D50AE6E-8F2C-4CAE-999A-CF19BCCF24DE}.Release|Win32.Deploy.0 = Release|x86
@@ -154,6 +192,9 @@ Global
 		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Debug|ARM.ActiveCfg = Debug|ARM
 		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Debug|ARM.Build.0 = Debug|ARM
 		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Debug|ARM.Deploy.0 = Debug|ARM
+		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Debug|Mixed Platforms.Deploy.0 = Debug|x86
 		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Debug|Win32.ActiveCfg = Debug|x86
 		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Debug|Win32.Build.0 = Debug|x86
 		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Debug|Win32.Deploy.0 = Debug|x86
@@ -163,6 +204,9 @@ Global
 		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Release|ARM.ActiveCfg = Release|ARM
 		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Release|ARM.Build.0 = Release|ARM
 		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Release|ARM.Deploy.0 = Release|ARM
+		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Release|Mixed Platforms.Build.0 = Release|x86
+		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Release|Mixed Platforms.Deploy.0 = Release|x86
 		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Release|Win32.ActiveCfg = Release|x86
 		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Release|Win32.Build.0 = Release|x86
 		{A7A9A1F4-9F82-49AE-B900-67A2956E23DC}.Release|Win32.Deploy.0 = Release|x86
@@ -172,6 +216,9 @@ Global
 		{92679B2C-887E-4B11-A889-A96334C0D37C}.Debug|ARM.ActiveCfg = Debug|ARM
 		{92679B2C-887E-4B11-A889-A96334C0D37C}.Debug|ARM.Build.0 = Debug|ARM
 		{92679B2C-887E-4B11-A889-A96334C0D37C}.Debug|ARM.Deploy.0 = Debug|ARM
+		{92679B2C-887E-4B11-A889-A96334C0D37C}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{92679B2C-887E-4B11-A889-A96334C0D37C}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{92679B2C-887E-4B11-A889-A96334C0D37C}.Debug|Mixed Platforms.Deploy.0 = Debug|x86
 		{92679B2C-887E-4B11-A889-A96334C0D37C}.Debug|Win32.ActiveCfg = Debug|x86
 		{92679B2C-887E-4B11-A889-A96334C0D37C}.Debug|Win32.Build.0 = Debug|x86
 		{92679B2C-887E-4B11-A889-A96334C0D37C}.Debug|Win32.Deploy.0 = Debug|x86
@@ -179,6 +226,9 @@ Global
 		{92679B2C-887E-4B11-A889-A96334C0D37C}.Release|ARM.ActiveCfg = Release|ARM
 		{92679B2C-887E-4B11-A889-A96334C0D37C}.Release|ARM.Build.0 = Release|ARM
 		{92679B2C-887E-4B11-A889-A96334C0D37C}.Release|ARM.Deploy.0 = Release|ARM
+		{92679B2C-887E-4B11-A889-A96334C0D37C}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{92679B2C-887E-4B11-A889-A96334C0D37C}.Release|Mixed Platforms.Build.0 = Release|x86
+		{92679B2C-887E-4B11-A889-A96334C0D37C}.Release|Mixed Platforms.Deploy.0 = Release|x86
 		{92679B2C-887E-4B11-A889-A96334C0D37C}.Release|Win32.ActiveCfg = Release|x86
 		{92679B2C-887E-4B11-A889-A96334C0D37C}.Release|Win32.Build.0 = Release|x86
 		{92679B2C-887E-4B11-A889-A96334C0D37C}.Release|Win32.Deploy.0 = Release|x86
@@ -186,6 +236,9 @@ Global
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Debug|ARM.ActiveCfg = Debug|ARM
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Debug|ARM.Build.0 = Debug|ARM
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Debug|ARM.Deploy.0 = Debug|ARM
+		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Debug|Mixed Platforms.Deploy.0 = Debug|x86
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Debug|Win32.ActiveCfg = Debug|x86
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Debug|Win32.Build.0 = Debug|x86
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Debug|Win32.Deploy.0 = Debug|x86
@@ -195,6 +248,9 @@ Global
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Release|ARM.ActiveCfg = Release|ARM
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Release|ARM.Build.0 = Release|ARM
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Release|ARM.Deploy.0 = Release|ARM
+		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Release|Mixed Platforms.Build.0 = Release|x86
+		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Release|Mixed Platforms.Deploy.0 = Release|x86
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Release|Win32.ActiveCfg = Release|x86
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Release|Win32.Build.0 = Release|x86
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE}.Release|Win32.Deploy.0 = Release|x86
@@ -204,6 +260,9 @@ Global
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Debug|ARM.ActiveCfg = Debug|ARM
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Debug|ARM.Build.0 = Debug|ARM
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Debug|ARM.Deploy.0 = Debug|ARM
+		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Debug|Mixed Platforms.ActiveCfg = Debug|x86
+		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Debug|Mixed Platforms.Build.0 = Debug|x86
+		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Debug|Mixed Platforms.Deploy.0 = Debug|x86
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Debug|Win32.ActiveCfg = Debug|x86
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Debug|Win32.Build.0 = Debug|x86
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Debug|Win32.Deploy.0 = Debug|x86
@@ -211,10 +270,25 @@ Global
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Release|ARM.ActiveCfg = Release|ARM
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Release|ARM.Build.0 = Release|ARM
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Release|ARM.Deploy.0 = Release|ARM
+		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Release|Mixed Platforms.ActiveCfg = Release|x86
+		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Release|Mixed Platforms.Build.0 = Release|x86
+		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Release|Mixed Platforms.Deploy.0 = Release|x86
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Release|Win32.ActiveCfg = Release|x86
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Release|Win32.Build.0 = Release|x86
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Release|Win32.Deploy.0 = Release|x86
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D}.Release|x64.ActiveCfg = Release|x86
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Debug|ARM.ActiveCfg = Debug|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Debug|Mixed Platforms.ActiveCfg = Debug|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Debug|Mixed Platforms.Build.0 = Debug|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Debug|Win32.ActiveCfg = Debug|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Debug|Win32.Build.0 = Debug|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Debug|x64.ActiveCfg = Debug|x64
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Release|ARM.ActiveCfg = Release|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Release|Mixed Platforms.ActiveCfg = Release|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Release|Mixed Platforms.Build.0 = Release|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Release|Win32.ActiveCfg = Release|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Release|Win32.Build.0 = Release|Win32
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3}.Release|x64.ActiveCfg = Release|Win32
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
@@ -234,5 +308,6 @@ Global
 		{92679B2C-887E-4B11-A889-A96334C0D37C} = {1D40D4AF-76F2-4FAB-8E9B-87C7DFA2E3DC}
 		{61DF9EEA-000D-4584-9C74-E7A93CC2D0DE} = {AEF4CC54-29B9-4E8C-BB6D-FA92B85C5D4A}
 		{94EACFD6-3F1F-4CBA-B879-03DA42BEA41D} = {AEF4CC54-29B9-4E8C-BB6D-FA92B85C5D4A}
+		{ADC3E224-BD1B-4BDD-B5B3-1C9981A03DF3} = {C69BA044-3BCD-42B4-8731-1A45AD15B31D}
 	EndGlobalSection
 EndGlobal
diff --git a/Samples/SamplesWin8.1/MediaPlayerCS/MediaPlayerCS.Windows/MainPage.xaml.cs b/Samples/SamplesWin8.1/MediaPlayerCS/MediaPlayerCS.Windows/MainPage.xaml.cs
index 1306f81..b702a7e 100644
--- a/Samples/SamplesWin8.1/MediaPlayerCS/MediaPlayerCS.Windows/MainPage.xaml.cs
+++ b/Samples/SamplesWin8.1/MediaPlayerCS/MediaPlayerCS.Windows/MainPage.xaml.cs
@@ -29,6 +29,10 @@ using Windows.UI.Xaml.Controls;
 
 namespace MediaPlayerCS
 {
+    using System.IO;
+    using System.Runtime.InteropServices.ComTypes;
+    using OneDrive.Media.Streams;
+
     public sealed partial class MainPage : Page
     {
         private FFmpegInteropMSS FFmpegMSS;
@@ -60,10 +64,18 @@ namespace MediaPlayerCS
                 // Open StorageFile as IRandomAccessStream to be passed to FFmpegInteropMSS
                 IRandomAccessStream readStream = await file.OpenAsync(FileAccessMode.Read);
 
+                Stream netStream = readStream.AsStream();
+
+                IStream iStream = netStream.ToComStream();
+
+
                 try
                 {
 					// Instantiate FFmpeg object and pass the stream from opened file
-                    FFmpegMSS = FFmpegInteropMSS.CreateFFmpegInteropMSSFromStream(readStream, forceDecodeAudio, forceDecodeVideo);
+                    //FFmpegMSS = FFmpegInteropMSS.CreateFFmpegInteropMSSFromStream(readStream, forceDecodeAudio, forceDecodeVideo);
+
+                    FFmpegMSS = FFmpegInteropMSS.CreateFFmpegInteropMSSFromStream(iStream, forceDecodeAudio, forceDecodeVideo);
+
                     MediaStreamSource mss = FFmpegMSS.GetMediaStreamSource();
 
                     if (mss != null)
diff --git a/Samples/SamplesWin8.1/MediaPlayerCS/MediaPlayerCS.Windows/MediaPlayerCS.Windows.csproj b/Samples/SamplesWin8.1/MediaPlayerCS/MediaPlayerCS.Windows/MediaPlayerCS.Windows.csproj
index d98eea0..09c357f 100644
--- a/Samples/SamplesWin8.1/MediaPlayerCS/MediaPlayerCS.Windows/MediaPlayerCS.Windows.csproj
+++ b/Samples/SamplesWin8.1/MediaPlayerCS/MediaPlayerCS.Windows/MediaPlayerCS.Windows.csproj
@@ -119,6 +119,10 @@
       <Project>{97248e49-6262-4c37-b118-224ff3b98fd0}</Project>
       <Name>FFmpegInterop.Windows</Name>
     </ProjectReference>
+    <Reference Include="OneDrive.Media.Streams, Version=1.0.117.0, Culture=neutral, PublicKeyToken=f4148d698ec140a6, processorArchitecture=AMD64">
+      <HintPath>d:\git\MediaTransformAndAnalysis\packages\OneDrive.MediaProcessingComponents.1.0.117\lib\OneDrive.Media.Streams.dll</HintPath>
+      <EmbedInteropTypes>False</EmbedInteropTypes>
+    </Reference>
   </ItemGroup>
   <PropertyGroup Condition=" '$(VisualStudioVersion)' == '' or '$(VisualStudioVersion)' &lt; '12.0' ">
     <VisualStudioVersion>12.0</VisualStudioVersion>
diff --git a/TestConsole/App.config b/TestConsole/App.config
new file mode 100644
index 0000000..88fa402
--- /dev/null
+++ b/TestConsole/App.config
@@ -0,0 +1,6 @@
+﻿<?xml version="1.0" encoding="utf-8" ?>
+<configuration>
+    <startup> 
+        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
+    </startup>
+</configuration>
\ No newline at end of file
diff --git a/TestConsole/Program.cs b/TestConsole/Program.cs
new file mode 100644
index 0000000..c262a1c
--- /dev/null
+++ b/TestConsole/Program.cs
@@ -0,0 +1,32 @@
+﻿// -----------------------------------------------------------------------
+//  <copyright file="Program.cs" company="Microsoft Corporation">
+//      Copyright (C) Microsoft Corporation. All rights reserved.
+//  </copyright>
+// -----------------------------------------------------------------------
+
+namespace TestConsole
+{
+    using System;
+    using System.IO;
+    using System.Runtime.InteropServices.ComTypes;
+    using FFmpegInterop;
+    using OneDrive.Media.Streams;
+
+    internal class Program
+    {
+        private static void Main(string[] args)
+        {
+            using (FileStream stream = new FileStream(@"c:\users\daviddi\videos\big_buck_bunny_480p_h264.mov", FileMode.Open))
+            {
+                System.Runtime.InteropServices.ComTypes.IStream comStream = stream.ToComStream();
+
+                FFmpegInteropMSS mss = FFmpegInteropMSS.CreateFFmpegInteropMSSFromStream(comStream, false, false);
+
+                mss.Starting(TimeSpan.FromSeconds(2));
+                MyMediaStreamSample sample = mss.SampleRequested(false);
+
+                sample.Dispose();
+            }
+        }
+    }
+}
diff --git a/TestConsole/Properties/AssemblyInfo.cs b/TestConsole/Properties/AssemblyInfo.cs
new file mode 100644
index 0000000..0d5b91e
--- /dev/null
+++ b/TestConsole/Properties/AssemblyInfo.cs
@@ -0,0 +1,36 @@
+﻿using System.Reflection;
+using System.Runtime.CompilerServices;
+using System.Runtime.InteropServices;
+
+// General Information about an assembly is controlled through the following 
+// set of attributes. Change these attribute values to modify the information
+// associated with an assembly.
+[assembly: AssemblyTitle("TestConsole")]
+[assembly: AssemblyDescription("")]
+[assembly: AssemblyConfiguration("")]
+[assembly: AssemblyCompany("")]
+[assembly: AssemblyProduct("TestConsole")]
+[assembly: AssemblyCopyright("Copyright ©  2017")]
+[assembly: AssemblyTrademark("")]
+[assembly: AssemblyCulture("")]
+
+// Setting ComVisible to false makes the types in this assembly not visible 
+// to COM components.  If you need to access a type in this assembly from 
+// COM, set the ComVisible attribute to true on that type.
+[assembly: ComVisible(false)]
+
+// The following GUID is for the ID of the typelib if this project is exposed to COM
+[assembly: Guid("d6661831-88b6-4f09-9a3d-563ad44ef098")]
+
+// Version information for an assembly consists of the following four values:
+//
+//      Major Version
+//      Minor Version 
+//      Build Number
+//      Revision
+//
+// You can specify all the values or you can default the Build and Revision Numbers 
+// by using the '*' as shown below:
+// [assembly: AssemblyVersion("1.0.*")]
+[assembly: AssemblyVersion("1.0.0.0")]
+[assembly: AssemblyFileVersion("1.0.0.0")]
diff --git a/TestConsole/TestConsole.csproj b/TestConsole/TestConsole.csproj
new file mode 100644
index 0000000..1396a12
--- /dev/null
+++ b/TestConsole/TestConsole.csproj
@@ -0,0 +1,117 @@
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="14.0" DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProjectGuid>{D6661831-88B6-4F09-9A3D-563AD44EF098}</ProjectGuid>
+    <OutputType>Exe</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>TestConsole</RootNamespace>
+    <AssemblyName>TestConsole</AssemblyName>
+    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>bin\x64\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>true</Prefer32Bit>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
+    <OutputPath>bin\x64\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>true</Prefer32Bit>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="OneDrive.Media.Streams">
+      <HintPath>..\..\MediaTransformAndAnalysis\packages\OneDrive.MediaProcessingComponents.1.0.117\lib\OneDrive.Media.Streams.dll</HintPath>
+      <EmbedInteropTypes>False</EmbedInteropTypes>
+    </Reference>
+    <Reference Include="System" />
+    <Reference Include="System.Core" />
+    <Reference Include="System.Xml.Linq" />
+    <Reference Include="System.Data.DataSetExtensions" />
+    <Reference Include="Microsoft.CSharp" />
+    <Reference Include="System.Data" />
+    <Reference Include="System.Net.Http" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="Program.cs" />
+    <Compile Include="Properties\AssemblyInfo.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <None Include="App.config" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\FFmpegInterop\CLR\FFmpegInterop.CLR\FFmpegInterop.CLR.vcxproj">
+      <Project>{adc3e224-bd1b-4bdd-b5b3-1c9981a03df3}</Project>
+      <Name>FFmpegInterop.CLR</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include=".NETFramework,Version=v4.5.2">
+      <Visible>False</Visible>
+      <ProductName>Microsoft .NET Framework 4.5.2 %28x86 and x64%29</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
+       Other similar extension points exist, see Microsoft.Common.targets.
+  <Target Name="BeforeBuild">
+  </Target>
+  <Target Name="AfterBuild">
+  </Target>
+  -->
+</Project>
\ No newline at end of file
-- 
2.14.1.windows.1

